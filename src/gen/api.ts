/* tslint:disable */
/* eslint-disable */
/**
 * StarkExpress API Docs
 * An API for the StarkExpress platform.
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface AllocateVaultModel
 */
export interface AllocateVaultModel {
  /**
   * The unique identifier of the asset.
   * @type {string}
   * @memberof AllocateVaultModel
   */
  assetId?: string;
  /**
   * The unique identifier of the user.
   * @type {string}
   * @memberof AllocateVaultModel
   */
  userId?: string;
  /**
   *
   * @type {DataAvailabilityModes}
   * @memberof AllocateVaultModel
   */
  dataAvailabilityMode: DataAvailabilityModes;
  /**
   * The hexadecimal string representation of the vault\'s asset token ID, if applicable (ie. ERC-721/ERC-1155).
   * @type {string}
   * @memberof AllocateVaultModel
   */
  tokenId?: string | null;
  /**
   * The hexadecimal string representation of the vault\'s asset minting blob, if applicable (ie. Mintable ERC-20/Mintable ERC-721/Mintable ERC-1155).
   * @type {string}
   * @memberof AllocateVaultModel
   */
  mintingBlob?: string | null;
}

/**
 *
 * @export
 * @enum {string}
 */

export const AssetType = {
  Eth: 'Eth',
  Erc20: 'Erc20',
  Erc721: 'Erc721',
  Erc1155: 'Erc1155',
  MintableErc20: 'MintableErc20',
  MintableErc721: 'MintableErc721',
  MintableErc1155: 'MintableErc1155',
} as const;

export type AssetType = (typeof AssetType)[keyof typeof AssetType];

/**
 * Request model to mint a batch of assets.
 * @export
 * @interface BatchMintRequestModel
 */
export interface BatchMintRequestModel {
  /**
   * The array of assets to mint grouped by user.
   * @type {Array<MintRequestDataModel>}
   * @memberof BatchMintRequestModel
   */
  users: Array<MintRequestDataModel>;
}
/**
 *
 * @export
 * @interface BigInteger
 */
export interface BigInteger {
  /**
   *
   * @type {number}
   * @memberof BigInteger
   */
  bitCount?: number;
  /**
   *
   * @type {number}
   * @memberof BigInteger
   */
  bitLength?: number;
  /**
   *
   * @type {number}
   * @memberof BigInteger
   */
  intValue?: number;
  /**
   *
   * @type {number}
   * @memberof BigInteger
   */
  intValueExact?: number;
  /**
   *
   * @type {number}
   * @memberof BigInteger
   */
  longValue?: number;
  /**
   *
   * @type {number}
   * @memberof BigInteger
   */
  longValueExact?: number;
  /**
   *
   * @type {number}
   * @memberof BigInteger
   */
  signValue?: number;
}
/**
 *
 * @export
 * @interface CalendarSystem
 */
export interface CalendarSystem {
  /**
   *
   * @type {string}
   * @memberof CalendarSystem
   */
  id?: string | null;
  /**
   *
   * @type {string}
   * @memberof CalendarSystem
   */
  name?: string | null;
  /**
   *
   * @type {number}
   * @memberof CalendarSystem
   */
  minYear?: number;
  /**
   *
   * @type {number}
   * @memberof CalendarSystem
   */
  maxYear?: number;
  /**
   *
   * @type {Array<Era>}
   * @memberof CalendarSystem
   */
  eras?: Array<Era> | null;
}
/**
 * Request model to configure the fee model for an operation.
 * @export
 * @interface ConfigureFeeModel
 */
export interface ConfigureFeeModel {
  /**
   *
   * @type {FeeAction}
   * @memberof ConfigureFeeModel
   */
  feeAction: FeeAction;
  /**
   * The basis points (1/100 of a percent) of the fee to take on the operation.
   * @type {number}
   * @memberof ConfigureFeeModel
   */
  basisPoints: number;
}

/**
 * Request model to create an orderbook.
 * @export
 * @interface CreateOrderbookModel
 */
export interface CreateOrderbookModel {
  /**
   * The ID of the orderbook base asset.
   * @type {string}
   * @memberof CreateOrderbookModel
   */
  baseAssetId: string;
  /**
   * The ID of the orderbook quote asset.
   * @type {string}
   * @memberof CreateOrderbookModel
   */
  quoteAssetId: string;
  /**
   * The orderbook base asset decimal precision.
   * @type {number}
   * @memberof CreateOrderbookModel
   */
  baseAssetPrecision: number;
  /**
   * The orderbook quote asset decimal precision.
   * @type {number}
   * @memberof CreateOrderbookModel
   */
  quoteAssetPrecision: number;
}
/**
 *
 * @export
 * @enum {string}
 */

export const DataAvailabilityModes = {
  ZkRollup: 'ZkRollup',
  Validium: 'Validium',
} as const;

export type DataAvailabilityModes =
  (typeof DataAvailabilityModes)[keyof typeof DataAvailabilityModes];

/**
 *
 * @export
 * @interface DeployAssetModel
 */
export interface DeployAssetModel {
  /**
   *
   * @type {AssetType}
   * @memberof DeployAssetModel
   */
  type: AssetType;
  /**
   * The token\'s name (eg. USD Coin).
   * @type {string}
   * @memberof DeployAssetModel
   */
  name: string;
  /**
   * The token\'s symbol (eg. USDC).
   * @type {string}
   * @memberof DeployAssetModel
   */
  symbol: string;
  /**
   * The token\'s metadata uri (for ERC-721 and ERC-1155 tokens).
   * @type {string}
   * @memberof DeployAssetModel
   */
  uri?: string | null;
  /**
   * The token\'s StarkEx asset quantum (for ERC-20 and ERC-1155 tokens).
   * @type {string}
   * @memberof DeployAssetModel
   */
  quantum?: string;
}

/**
 *
 * @export
 * @interface DepositDetailsDto
 */
export interface DepositDetailsDto {
  /**
   * The smart contract address that processes on-chain deposits.
   * @type {string}
   * @memberof DepositDetailsDto
   */
  operatorContractAddress?: string | null;
  /**
   * The asset\'s smart contract address.
   * @type {string}
   * @memberof DepositDetailsDto
   */
  assetContractAddress?: string | null;
  /**
   * The deposit function to use on-chain.
   * @type {string}
   * @memberof DepositDetailsDto
   */
  depositFunction?: string | null;
  /**
   * The user\'s public STARK key
   * @type {string}
   * @memberof DepositDetailsDto
   */
  starkKey?: string | null;
  /**
   * The asset type identifier.
   * @type {string}
   * @memberof DepositDetailsDto
   */
  assetType?: string | null;
  /**
   * The token Id for ERC-721 and ERC-1155 assets.
   * @type {string}
   * @memberof DepositDetailsDto
   */
  tokenId?: string | null;
  /**
   * The user\'s vault id.
   * @type {string}
   * @memberof DepositDetailsDto
   */
  vaultId?: string;
  /**
   * The quantized amount to deposit ERC-20 and ERC-1155 assets.
   * @type {string}
   * @memberof DepositDetailsDto
   */
  quantizedAmount?: string | null;
  /**
   * The amount to deposit ETH.
   * @type {string}
   * @memberof DepositDetailsDto
   */
  amount?: string | null;
}
/**
 *
 * @export
 * @interface DepositDetailsModel
 */
export interface DepositDetailsModel {
  /**
   * The ID of the user for which the vault should be allocated.
   * @type {string}
   * @memberof DepositDetailsModel
   */
  userId: string;
  /**
   * The ID of the vault\'s asset.
   * @type {string}
   * @memberof DepositDetailsModel
   */
  assetId: string;
  /**
   *
   * @type {DataAvailabilityModes}
   * @memberof DepositDetailsModel
   */
  dataAvailabilityMode: DataAvailabilityModes;
  /**
   * The hexadecimal string representation of the vault\'s asset token ID, if applicable (ie. ERC-721/ERC-1155).
   * @type {string}
   * @memberof DepositDetailsModel
   */
  tokenId?: string | null;
  /**
   * The amount of the asset to be deposited.
   * @type {string}
   * @memberof DepositDetailsModel
   */
  amount: string;
}

/**
 * Request model to enable an asset in the tenant system.
 * @export
 * @interface DisableAssetModel
 */
export interface DisableAssetModel {
  /**
   * The unique identifier of the asset to disable.
   * @type {string}
   * @memberof DisableAssetModel
   */
  assetId: string;
}
/**
 *
 * @export
 * @interface DomainDto
 */
export interface DomainDto {
  /**
   * The name of the domain for the EIP712 signing.
   * @type {string}
   * @memberof DomainDto
   */
  name?: string | null;
  /**
   * The version of the domain for the EIP712 signing.
   * @type {string}
   * @memberof DomainDto
   */
  version?: string | null;
  /**
   * The chainId for the domain for the EIP712 signing.
   * @type {number}
   * @memberof DomainDto
   */
  chainId?: number | null;
  /**
   * The verifying contract for the domain for the EIP712 signing.
   * @type {string}
   * @memberof DomainDto
   */
  verifyingContract?: string | null;
}
/**
 * Request model to enable an asset in the tenant system.
 * @export
 * @interface EnableAssetModel
 */
export interface EnableAssetModel {
  /**
   * The unique identifier of the asset to enable.
   * @type {string}
   * @memberof EnableAssetModel
   */
  assetId: string;
}
/**
 *
 * @export
 * @interface Era
 */
export interface Era {
  /**
   *
   * @type {string}
   * @memberof Era
   */
  name?: string | null;
}
/**
 *
 * @export
 * @enum {string}
 */

export const FeeAction = {
  Transfer: 'Transfer',
  ConditionalTransfer: 'ConditionalTransfer',
  MakerOrder: 'MakerOrder',
  TakerOrder: 'TakerOrder',
} as const;

export type FeeAction = (typeof FeeAction)[keyof typeof FeeAction];

/**
 *
 * @export
 * @interface FeeConfigDto
 */
export interface FeeConfigDto {
  /**
   * The unique identifier of the fee configuration.
   * @type {string}
   * @memberof FeeConfigDto
   */
  feeId?: string;
  /**
   *
   * @type {FeeAction}
   * @memberof FeeConfigDto
   */
  action?: FeeAction;
  /**
   * The basis points (1/100 of a percent) of the fee to take on the operation.
   * @type {number}
   * @memberof FeeConfigDto
   */
  basisPoints?: number;
}

/**
 *
 * @export
 * @interface FeeDto
 */
export interface FeeDto {
  /**
   * The vault ID of the fee sender.
   * @type {string}
   * @memberof FeeDto
   */
  vaultId?: string;
  /**
   *
   * @type {BigInteger}
   * @memberof FeeDto
   */
  vaultChainId?: BigInteger;
  /**
   * The StarkEx ID of the fee asset to be collected.
   * @type {string}
   * @memberof FeeDto
   */
  assetId?: string | null;
  /**
   *
   * @type {BigInteger}
   * @memberof FeeDto
   */
  quantizedAmount?: BigInteger;
}
/**
 *
 * @export
 * @enum {string}
 */

export const FilterOptions = {
  StartsWith: 'StartsWith',
  EndsWith: 'EndsWith',
  Contains: 'Contains',
  DoesNotContain: 'DoesNotContain',
  IsEmpty: 'IsEmpty',
  IsNotEmpty: 'IsNotEmpty',
  IsGreaterThan: 'IsGreaterThan',
  IsGreaterThanOrEqualTo: 'IsGreaterThanOrEqualTo',
  IsLessThan: 'IsLessThan',
  IsLessThanOrEqualTo: 'IsLessThanOrEqualTo',
  IsEqualTo: 'IsEqualTo',
  IsNotEqualTo: 'IsNotEqualTo',
} as const;

export type FilterOptions = (typeof FilterOptions)[keyof typeof FilterOptions];

/**
 *
 * @export
 * @enum {string}
 */

export const IsoDayOfWeek = {
  None: 'None',
  Monday: 'Monday',
  Tuesday: 'Tuesday',
  Wednesday: 'Wednesday',
  Thursday: 'Thursday',
  Friday: 'Friday',
  Saturday: 'Saturday',
  Sunday: 'Sunday',
} as const;

export type IsoDayOfWeek = (typeof IsoDayOfWeek)[keyof typeof IsoDayOfWeek];

/**
 *
 * @export
 * @interface LocalDate
 */
export interface LocalDate {
  /**
   *
   * @type {CalendarSystem}
   * @memberof LocalDate
   */
  calendar?: CalendarSystem;
  /**
   *
   * @type {number}
   * @memberof LocalDate
   */
  year?: number;
  /**
   *
   * @type {number}
   * @memberof LocalDate
   */
  month?: number;
  /**
   *
   * @type {number}
   * @memberof LocalDate
   */
  day?: number;
  /**
   *
   * @type {IsoDayOfWeek}
   * @memberof LocalDate
   */
  dayOfWeek?: IsoDayOfWeek;
  /**
   *
   * @type {number}
   * @memberof LocalDate
   */
  yearOfEra?: number;
  /**
   *
   * @type {Era}
   * @memberof LocalDate
   */
  era?: Era;
  /**
   *
   * @type {number}
   * @memberof LocalDate
   */
  dayOfYear?: number;
}

/**
 *
 * @export
 * @interface MemberDescriptionDto
 */
export interface MemberDescriptionDto {
  /**
   * The name of the variable.
   * @type {string}
   * @memberof MemberDescriptionDto
   */
  name?: string | null;
  /**
   * The type of the variable.
   * @type {string}
   * @memberof MemberDescriptionDto
   */
  type?: string | null;
}
/**
 *
 * @export
 * @interface MemberValueDto
 */
export interface MemberValueDto {
  /**
   * The type name of the variable.
   * @type {string}
   * @memberof MemberValueDto
   */
  typeName?: string | null;
  /**
   * The value of the variable.
   * @type {string}
   * @memberof MemberValueDto
   */
  value?: string | null;
}
/**
 *
 * @export
 * @interface MessageDto
 */
export interface MessageDto {
  /**
   *
   * @type {string}
   * @memberof MessageDto
   */
  username?: string | null;
  /**
   *
   * @type {string}
   * @memberof MessageDto
   */
  starkKey?: string | null;
  /**
   *
   * @type {string}
   * @memberof MessageDto
   */
  address?: string | null;
}
/**
 * Model containing information to mint an asset.
 * @export
 * @interface MintDataModel
 */
export interface MintDataModel {
  /**
   * The hexadecimal string representation of the data to be associated with the asset being minted.
   * @type {string}
   * @memberof MintDataModel
   */
  mintingBlob: string;
  /**
   * The unique identifier of the asset being minted.
   * @type {string}
   * @memberof MintDataModel
   */
  assetId: string;
  /**
   * The amount of the asset to be minted.
   * @type {string}
   * @memberof MintDataModel
   */
  amount: string;
  /**
   *
   * @type {DataAvailabilityModes}
   * @memberof MintDataModel
   */
  dataAvailabilityMode: DataAvailabilityModes;
}

/**
 * Request model to mint a batch of assets.
 * @export
 * @interface MintRequestDataModel
 */
export interface MintRequestDataModel {
  /**
   * The ID of the user for which the assets should be minted.
   * @type {string}
   * @memberof MintRequestDataModel
   */
  userId: string;
  /**
   * The array of assets to mint for the user.
   * @type {Array<MintDataModel>}
   * @memberof MintRequestDataModel
   */
  mints: Array<MintDataModel>;
}
/**
 *
 * @export
 * @interface OrderDetailsDto
 */
export interface OrderDetailsDto {
  /**
   * The STARK key of the user.
   * @type {string}
   * @memberof OrderDetailsDto
   */
  starkKey?: string | null;
  /**
   * The amount to be sold, in quantized form.
   * @type {string}
   * @memberof OrderDetailsDto
   */
  sellQuantizedAmount?: string;
  /**
   * The amount to be bough, in quantized form.
   * @type {string}
   * @memberof OrderDetailsDto
   */
  buyQuantizedAmount?: string;
  /**
   * The vault chain ID for the asset being sold.
   * @type {string}
   * @memberof OrderDetailsDto
   */
  sellVaultChainId?: string;
  /**
   * The vault chain ID for the asset being bought.
   * @type {string}
   * @memberof OrderDetailsDto
   */
  buyVaultChainId?: string;
  /**
   *
   * @type {FeeDto}
   * @memberof OrderDetailsDto
   */
  fee?: FeeDto;
  /**
   * The timestamp at which this order becomes invalid, in seconds since the Unix epoch.
   * @type {number}
   * @memberof OrderDetailsDto
   */
  expirationTimestamp?: number;
  /**
   * The unique nonce for the order.
   * @type {number}
   * @memberof OrderDetailsDto
   */
  nonce?: number;
  /**
   * The signable payload for the order.
   * @type {string}
   * @memberof OrderDetailsDto
   */
  signablePayload?: string | null;
}
/**
 * Request model to fetch details for a signable order.
 * @export
 * @interface OrderDetailsModel
 */
export interface OrderDetailsModel {
  /**
   * The ID of the orderbook.
   * @type {string}
   * @memberof OrderDetailsModel
   */
  orderbookId: string;
  /**
   * The unique identifier of the user submitting the order.
   * @type {string}
   * @memberof OrderDetailsModel
   */
  userId: string;
  /**
   *
   * @type {OrderSide}
   * @memberof OrderDetailsModel
   */
  side: OrderSide;
  /**
   * The order price.
   * @type {number}
   * @memberof OrderDetailsModel
   */
  price: number;
  /**
   *
   * @type {BigInteger}
   * @memberof OrderDetailsModel
   */
  amount: BigInteger;
  /**
   *
   * @type {DataAvailabilityModes}
   * @memberof OrderDetailsModel
   */
  sellDataAvailabilityMode: DataAvailabilityModes;
  /**
   *
   * @type {DataAvailabilityModes}
   * @memberof OrderDetailsModel
   */
  buyDataAvailabilityMode: DataAvailabilityModes;
}

/**
 *
 * @export
 * @interface OrderDto
 */
export interface OrderDto {
  /**
   * The ID of the order.
   * @type {string}
   * @memberof OrderDto
   */
  orderId?: string;
  /**
   * The ID of the orderbook.
   * @type {string}
   * @memberof OrderDto
   */
  orderbookId?: string;
  /**
   * The order price.
   * @type {number}
   * @memberof OrderDto
   */
  price?: number;
  /**
   * The original order amount.
   * @type {string}
   * @memberof OrderDto
   */
  originalAmount?: string;
  /**
   * The executed order amount.
   * @type {string}
   * @memberof OrderDto
   */
  executedAmount?: string;
  /**
   * The order fills.
   * @type {Array<OrderFillDto>}
   * @memberof OrderDto
   */
  fills?: Array<OrderFillDto> | null;
}
/**
 *
 * @export
 * @interface OrderFillDto
 */
export interface OrderFillDto {
  /**
   * The fill price.
   * @type {number}
   * @memberof OrderFillDto
   */
  price?: number;
  /**
   * The fill amount.
   * @type {string}
   * @memberof OrderFillDto
   */
  amount?: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const OrderSide = {
  Bid: 'Bid',
  Ask: 'Ask',
} as const;

export type OrderSide = (typeof OrderSide)[keyof typeof OrderSide];

/**
 *
 * @export
 * @interface OrderbookAssetDto
 */
export interface OrderbookAssetDto {
  /**
   * The ID of the asset.
   * @type {string}
   * @memberof OrderbookAssetDto
   */
  assetId?: string;
  /**
   * The orderbook precision of the asset.
   * @type {number}
   * @memberof OrderbookAssetDto
   */
  precision?: number;
}
/**
 *
 * @export
 * @interface OrderbookDto
 */
export interface OrderbookDto {
  /**
   * The ID of the orderbook.
   * @type {string}
   * @memberof OrderbookDto
   */
  orderbookId?: string;
  /**
   * The orderbook symbol.
   * @type {string}
   * @memberof OrderbookDto
   */
  symbol?: string | null;
  /**
   *
   * @type {OrderbookAssetDto}
   * @memberof OrderbookDto
   */
  baseAsset?: OrderbookAssetDto;
  /**
   *
   * @type {OrderbookAssetDto}
   * @memberof OrderbookDto
   */
  quoteAsset?: OrderbookAssetDto;
}
/**
 *
 * @export
 * @interface OrderbookLevel1DataDto
 */
export interface OrderbookLevel1DataDto {
  /**
   * The ID of the orderbook.
   * @type {string}
   * @memberof OrderbookLevel1DataDto
   */
  orderbookId?: string;
  /**
   * The highest posted price where someone is willing to buy an asset.
   * @type {number}
   * @memberof OrderbookLevel1DataDto
   */
  bidPrice?: number;
  /**
   * The number of asset shares that users are trying to buy at the bid price.
   * @type {string}
   * @memberof OrderbookLevel1DataDto
   */
  bidSize?: string;
  /**
   * The lowest posted price where someone is willing to sell an asset.
   * @type {number}
   * @memberof OrderbookLevel1DataDto
   */
  askPrice?: number;
  /**
   * The number of asset shares that users are trying to sell at the bid ask.
   * @type {string}
   * @memberof OrderbookLevel1DataDto
   */
  askSize?: string;
  /**
   * The price at which the last transaction occurred.
   * @type {number}
   * @memberof OrderbookLevel1DataDto
   */
  lastPrice?: number;
  /**
   * The number of asset shares involved in the last transaction.
   * @type {string}
   * @memberof OrderbookLevel1DataDto
   */
  lastSize?: string;
}
/**
 *
 * @export
 * @interface OrderbookLevel2DataDto
 */
export interface OrderbookLevel2DataDto {
  /**
   * The ID of the orderbook.
   * @type {string}
   * @memberof OrderbookLevel2DataDto
   */
  orderbookId?: string;
  /**
   * The orderbook bids.
   * @type {Array<OrderbookLevel2EntryDto>}
   * @memberof OrderbookLevel2DataDto
   */
  bids?: Array<OrderbookLevel2EntryDto> | null;
  /**
   * The orderbook asks.
   * @type {Array<OrderbookLevel2EntryDto>}
   * @memberof OrderbookLevel2DataDto
   */
  asks?: Array<OrderbookLevel2EntryDto> | null;
}
/**
 *
 * @export
 * @interface OrderbookLevel2EntryDto
 */
export interface OrderbookLevel2EntryDto {
  /**
   * The orderbook level price.
   * @type {number}
   * @memberof OrderbookLevel2EntryDto
   */
  price?: number;
  /**
   * The orderbook level amount.
   * @type {string}
   * @memberof OrderbookLevel2EntryDto
   */
  amount?: string;
}
/**
 *
 * @export
 * @interface PaginationDto
 */
export interface PaginationDto {
  /**
   * The page number.
   * @type {number}
   * @memberof PaginationDto
   */
  pageNumber?: number;
  /**
   * The number of items per page.
   * @type {number}
   * @memberof PaginationDto
   */
  pageSize?: number;
  /**
   * Indicates whether there is a next page available.
   * @type {boolean}
   * @memberof PaginationDto
   */
  hasNext?: boolean;
}
/**
 *
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
  [key: string]: any;

  /**
   *
   * @type {string}
   * @memberof ProblemDetails
   */
  type?: string | null;
  /**
   *
   * @type {string}
   * @memberof ProblemDetails
   */
  title?: string | null;
  /**
   *
   * @type {number}
   * @memberof ProblemDetails
   */
  status?: number | null;
  /**
   *
   * @type {string}
   * @memberof ProblemDetails
   */
  detail?: string | null;
  /**
   *
   * @type {string}
   * @memberof ProblemDetails
   */
  instance?: string | null;
}
/**
 *
 * @export
 * @interface RegisterDetailsDto
 */
export interface RegisterDetailsDto {
  /**
   *
   * @type {DomainDto}
   * @memberof RegisterDetailsDto
   */
  domain?: DomainDto;
  /**
   * The types in the EIP712 message.
   * @type {{ [key: string]: Array<MemberDescriptionDto>; }}
   * @memberof RegisterDetailsDto
   */
  types?: { [key: string]: Array<MemberDescriptionDto> } | null;
  /**
   * The message primary type.
   * @type {string}
   * @memberof RegisterDetailsDto
   */
  primaryType?: string | null;
  /**
   *
   * @type {MessageDto}
   * @memberof RegisterDetailsDto
   */
  message?: MessageDto;
  /**
   * The STARK key of the sender.
   * @type {Array<MemberValueDto>}
   * @memberof RegisterDetailsDto
   */
  domainRawValues?: Array<MemberValueDto> | null;
  /**
   * The signable payload.
   * @type {string}
   * @memberof RegisterDetailsDto
   */
  signablePayload?: string | null;
}
/**
 *
 * @export
 * @interface RegisterUserModel
 */
export interface RegisterUserModel {
  /**
   * The username of the user.
   * @type {string}
   * @memberof RegisterUserModel
   */
  username: string;
  /**
   * The STARK key of the user.
   * @type {string}
   * @memberof RegisterUserModel
   */
  starkKey: string;
  /**
   *
   * @type {SignatureModel}
   * @memberof RegisterUserModel
   */
  starkSignature: SignatureModel;
  /**
   * The Ethereum address associated with the user.
   * @type {string}
   * @memberof RegisterUserModel
   */
  address: string;
  /**
   * The EIP-712 Signature of the Username, Stark Key and Address.
   * @type {string}
   * @memberof RegisterUserModel
   */
  eip712Signature: string;
}
/**
 * Settlement details model.
 * @export
 * @interface SettlementInfoModel
 */
export interface SettlementInfoModel {
  /**
   * The unique identifier of the destination vault for the order A fee.
   * @type {string}
   * @memberof SettlementInfoModel
   */
  orderAFeeDestinationVaultId?: string | null;
  /**
   * The order A fee amount.
   * @type {string}
   * @memberof SettlementInfoModel
   */
  orderAFeeAmount?: string | null;
  /**
   * The unique identifier of the destination vault for the order B fee.
   * @type {string}
   * @memberof SettlementInfoModel
   */
  orderBFeeDestinationVaultId?: string | null;
  /**
   * The order B fee amount.
   * @type {string}
   * @memberof SettlementInfoModel
   */
  orderBFeeAmount?: string | null;
}
/**
 *
 * @export
 * @interface SettlementOrderModel
 */
export interface SettlementOrderModel {
  /**
   * The unique identifier of the buy vault.
   * @type {string}
   * @memberof SettlementOrderModel
   */
  buyVaultId: string;
  /**
   * The amount of the asset to be settled, in quantized form.
   * @type {string}
   * @memberof SettlementOrderModel
   */
  buyQuantizedAmount: string;
  /**
   * The unique identifier of the sell vault.
   * @type {string}
   * @memberof SettlementOrderModel
   */
  sellVaultId: string;
  /**
   * The amount of the asset to be settled, in quantized form.
   * @type {string}
   * @memberof SettlementOrderModel
   */
  sellQuantizedAmount: string;
  /**
   * The unique identifier of the transfer sender vault.
   * @type {string}
   * @memberof SettlementOrderModel
   */
  feeVaultId?: string | null;
  /**
   * The amount of the fee asset to be collected, in quantized form.
   * @type {string}
   * @memberof SettlementOrderModel
   */
  feeQuantizedAmount?: string | null;
  /**
   * The unique nonce for the transfer.
   * @type {number}
   * @memberof SettlementOrderModel
   */
  nonce: number;
  /**
   *
   * @type {SignatureModel}
   * @memberof SettlementOrderModel
   */
  signature: SignatureModel;
  /**
   * The timestamp at which this transfer becomes invalid, in seconds since the Unix epoch.
   * @type {number}
   * @memberof SettlementOrderModel
   */
  expirationTimestamp: number;
}
/**
 * Model representing an ECDSA signature data.
 * @export
 * @interface SignatureModel
 */
export interface SignatureModel {
  /**
   * The R component of the ECDSA signature, represented as a hexadecimal string.
   * @type {string}
   * @memberof SignatureModel
   */
  r: string;
  /**
   * The S component of the ECDSA signature, represented as a hexadecimal string.
   * @type {string}
   * @memberof SignatureModel
   */
  s: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const StarkExOperation = {
  Deposit: 'Deposit',
  Withdrawal: 'Withdrawal',
  Mint: 'Mint',
  MultiTransaction: 'MultiTransaction',
  Transfer: 'Transfer',
  FullWithdrawal: 'FullWithdrawal',
  FalseFullWithdrawal: 'FalseFullWithdrawal',
  Settlement: 'Settlement',
} as const;

export type StarkExOperation =
  (typeof StarkExOperation)[keyof typeof StarkExOperation];

/**
 * Request model to submit an orderbook order.
 * @export
 * @interface SubmitOrderModel
 */
export interface SubmitOrderModel {
  /**
   * The ID of the orderbook.
   * @type {string}
   * @memberof SubmitOrderModel
   */
  orderbookId: string;
  /**
   * The unique identifier of the user submitting the order.
   * @type {string}
   * @memberof SubmitOrderModel
   */
  userId: string;
  /**
   *
   * @type {OrderSide}
   * @memberof SubmitOrderModel
   */
  side: OrderSide;
  /**
   * The order price.
   * @type {number}
   * @memberof SubmitOrderModel
   */
  price: number;
  /**
   * The order amount.
   * @type {string}
   * @memberof SubmitOrderModel
   */
  amount: string;
  /**
   *
   * @type {DataAvailabilityModes}
   * @memberof SubmitOrderModel
   */
  sellDataAvailabilityMode: DataAvailabilityModes;
  /**
   *
   * @type {DataAvailabilityModes}
   * @memberof SubmitOrderModel
   */
  buyDataAvailabilityMode: DataAvailabilityModes;
  /**
   * The timestamp at which this order becomes invalid, in seconds since the Unix epoch.
   * @type {number}
   * @memberof SubmitOrderModel
   */
  expirationTimestamp: number;
  /**
   * The unique nonce for the order.
   * @type {number}
   * @memberof SubmitOrderModel
   */
  nonce: number;
  /**
   *
   * @type {SignatureModel}
   * @memberof SubmitOrderModel
   */
  signature: SignatureModel;
}

/**
 * Request model to transfer assets between users.
 * @export
 * @interface SubmitSettlementModel
 */
export interface SubmitSettlementModel {
  /**
   *
   * @type {SettlementOrderModel}
   * @memberof SubmitSettlementModel
   */
  orderA: SettlementOrderModel;
  /**
   *
   * @type {SettlementOrderModel}
   * @memberof SubmitSettlementModel
   */
  orderB: SettlementOrderModel;
  /**
   *
   * @type {SettlementInfoModel}
   * @memberof SubmitSettlementModel
   */
  settlementInfo?: SettlementInfoModel;
}
/**
 *
 * @export
 * @interface TenantAssetDto
 */
export interface TenantAssetDto {
  /**
   * The unique identifier of the asset.
   * @type {string}
   * @memberof TenantAssetDto
   */
  assetId?: string;
  /**
   * The asset type used for on-chain interactions.
   * @type {string}
   * @memberof TenantAssetDto
   */
  assetType?: string | null;
  /**
   * The Ethereum address of the asset.
   * @type {string}
   * @memberof TenantAssetDto
   */
  address?: string | null;
  /**
   * The name of the asset.
   * @type {string}
   * @memberof TenantAssetDto
   */
  name?: string | null;
  /**
   * The symbol of the asset.
   * @type {string}
   * @memberof TenantAssetDto
   */
  symbol?: string | null;
  /**
   * The quantum of the asset.
   * @type {string}
   * @memberof TenantAssetDto
   */
  quantum?: string;
  /**
   *
   * @type {AssetType}
   * @memberof TenantAssetDto
   */
  type?: AssetType;
  /**
   * Is the asset enabled for the given tenant
   * @type {boolean}
   * @memberof TenantAssetDto
   */
  enabled?: boolean;
  /**
   * Has the asset register transaction been confirmed in the Blockchain
   * @type {boolean}
   * @memberof TenantAssetDto
   */
  confirmed?: boolean;
}

/**
 *
 * @export
 * @interface TenantAssetDtoPaginatedResponseDto
 */
export interface TenantAssetDtoPaginatedResponseDto {
  /**
   * The data in the paginated response.
   * @type {Array<TenantAssetDto>}
   * @memberof TenantAssetDtoPaginatedResponseDto
   */
  data?: Array<TenantAssetDto> | null;
  /**
   *
   * @type {PaginationDto}
   * @memberof TenantAssetDtoPaginatedResponseDto
   */
  pagination?: PaginationDto;
  /**
   * The total count of results available.
   * @type {number}
   * @memberof TenantAssetDtoPaginatedResponseDto
   */
  totalCount?: number;
}
/**
 *
 * @export
 * @interface TimeSeriesCostsDto
 */
export interface TimeSeriesCostsDto {
  /**
   *
   * @type {LocalDate}
   * @memberof TimeSeriesCostsDto
   */
  key?: LocalDate;
  /**
   * Time series value (value axis).
   * @type {number}
   * @memberof TimeSeriesCostsDto
   */
  value?: number;
}
/**
 *
 * @export
 * @interface TimeSeriesCostsResponseDto
 */
export interface TimeSeriesCostsResponseDto {
  /**
   * Total cost amount of elements in a given time interval
   * @type {number}
   * @memberof TimeSeriesCostsResponseDto
   */
  totalCost?: number;
  /**
   * The data necessary for the time series chart.
   * @type {Array<TimeSeriesCostsDto>}
   * @memberof TimeSeriesCostsResponseDto
   */
  data?: Array<TimeSeriesCostsDto> | null;
}
/**
 *
 * @export
 * @interface TimeSeriesDto
 */
export interface TimeSeriesDto {
  /**
   *
   * @type {LocalDate}
   * @memberof TimeSeriesDto
   */
  key?: LocalDate;
  /**
   * Time series value (value axis).
   * @type {number}
   * @memberof TimeSeriesDto
   */
  value?: number;
}
/**
 *
 * @export
 * @interface TimeSeriesResponseDto
 */
export interface TimeSeriesResponseDto {
  /**
   * Total amount of elements in a given time interval
   * @type {number}
   * @memberof TimeSeriesResponseDto
   */
  totalCount?: number;
  /**
   * The data necessary for the time series chart.
   * @type {Array<TimeSeriesDto>}
   * @memberof TimeSeriesResponseDto
   */
  data?: Array<TimeSeriesDto> | null;
}
/**
 *
 * @export
 * @interface TransactionDto
 */
export interface TransactionDto {
  /**
   * The ID of the transaction.
   * @type {string}
   * @memberof TransactionDto
   */
  transactionId?: string;
  /**
   * The sequence ID of the transaction in StarkEx.
   * @type {number}
   * @memberof TransactionDto
   */
  starkExTransactionId?: number | null;
  /**
   * The ID of the StarkEx instance.
   * @type {string}
   * @memberof TransactionDto
   */
  starkExInstanceId?: string;
  /**
   * The ID of the tenant.
   * @type {string}
   * @memberof TransactionDto
   */
  tenantId?: string;
  /**
   *
   * @type {StarkExOperation}
   * @memberof TransactionDto
   */
  operation?: StarkExOperation;
  /**
   *
   * @type {TransactionStatus}
   * @memberof TransactionDto
   */
  status?: TransactionStatus;
  /**
   * The date the transaction was created.
   * @type {string}
   * @memberof TransactionDto
   */
  creationDate?: string;
  /**
   *
   * @type {TransactionModel}
   * @memberof TransactionDto
   */
  rawTransaction?: TransactionModel;
}

/**
 *
 * @export
 * @interface TransactionDtoPaginatedResponseDto
 */
export interface TransactionDtoPaginatedResponseDto {
  /**
   * The data in the paginated response.
   * @type {Array<TransactionDto>}
   * @memberof TransactionDtoPaginatedResponseDto
   */
  data?: Array<TransactionDto> | null;
  /**
   *
   * @type {PaginationDto}
   * @memberof TransactionDtoPaginatedResponseDto
   */
  pagination?: PaginationDto;
  /**
   * The total count of results available.
   * @type {number}
   * @memberof TransactionDtoPaginatedResponseDto
   */
  totalCount?: number;
}
/**
 *
 * @export
 * @interface TransactionModel
 */
export interface TransactionModel {
  /**
   *
   * @type {string}
   * @memberof TransactionModel
   */
  type?: string | null;
}
/**
 *
 * @export
 * @enum {string}
 */

export const TransactionStatus = {
  Streamed: 'Streamed',
  Pending: 'Pending',
  Confirmed: 'Confirmed',
  Reverted: 'Reverted',
  Failed: 'Failed',
} as const;

export type TransactionStatus =
  (typeof TransactionStatus)[keyof typeof TransactionStatus];

/**
 *
 * @export
 * @interface TransferDetailsDto
 */
export interface TransferDetailsDto {
  /**
   * The STARK key of the sender.
   * @type {string}
   * @memberof TransferDetailsDto
   */
  senderStarkKey?: string | null;
  /**
   * The vault chain ID of the sender.
   * @type {string}
   * @memberof TransferDetailsDto
   */
  senderVaultChainId?: string;
  /**
   * The vault ID of the sender.
   * @type {string}
   * @memberof TransferDetailsDto
   */
  senderVaultId?: string;
  /**
   * The STARK key of the receiver.
   * @type {string}
   * @memberof TransferDetailsDto
   */
  receiverStarkKey?: string | null;
  /**
   * The vault chain ID of the receiver.
   * @type {string}
   * @memberof TransferDetailsDto
   */
  receiverVaultChainId?: string;
  /**
   * The vault ID of the receiver.
   * @type {string}
   * @memberof TransferDetailsDto
   */
  receiverVaultId?: string;
  /**
   * The StarkEx ID of the asset being transferred.
   * @type {string}
   * @memberof TransferDetailsDto
   */
  assetId?: string | null;
  /**
   * The amount of the asset to be transferred, in quantized form.
   * @type {string}
   * @memberof TransferDetailsDto
   */
  quantizedAmount?: string;
  /**
   * The vault chain ID of the fee sender.
   * @type {string}
   * @memberof TransferDetailsDto
   */
  feeVaultChainId?: string;
  /**
   * The vault ID of the fee sender.
   * @type {string}
   * @memberof TransferDetailsDto
   */
  feeVaultId?: string;
  /**
   * The amount of the fee asset to be collected, in quantized form.
   * @type {string}
   * @memberof TransferDetailsDto
   */
  feeQuantizedAmount?: string;
  /**
   * The StarkEx ID of the fee asset to be collected.
   * @type {string}
   * @memberof TransferDetailsDto
   */
  feeAssetId?: string | null;
  /**
   * The timestamp at which this transfer becomes invalid, in seconds since the Unix epoch.
   * @type {number}
   * @memberof TransferDetailsDto
   */
  expirationTimestamp?: number;
  /**
   * The unique nonce for the transfer.
   * @type {number}
   * @memberof TransferDetailsDto
   */
  nonce?: number;
  /**
   * The signable payload for the transfer.
   * @type {string}
   * @memberof TransferDetailsDto
   */
  signablePayload?: string | null;
}
/**
 * Request model to fetch details for a signable transfer.
 * @export
 * @interface TransferDetailsModel
 */
export interface TransferDetailsModel {
  /**
   * The unique identifier of the user sending the transfer.
   * @type {string}
   * @memberof TransferDetailsModel
   */
  senderUserId: string;
  /**
   * The unique identifier of the user receiving the transfer.
   * @type {string}
   * @memberof TransferDetailsModel
   */
  receiverUserId: string;
  /**
   * The unique identifier of the asset being transferred.
   * @type {string}
   * @memberof TransferDetailsModel
   */
  assetId: string;
  /**
   * The hexadecimal string representation of the token ID, if applicable (ie. ERC-721/ERC-1155).
   * @type {string}
   * @memberof TransferDetailsModel
   */
  tokenId?: string | null;
  /**
   * The hexadecimal string representation of the minting blob, if applicable (ie. Mintable ERC-20/ERC-721/ERC-1155).
   * @type {string}
   * @memberof TransferDetailsModel
   */
  mintingBlob?: string | null;
  /**
   *
   * @type {DataAvailabilityModes}
   * @memberof TransferDetailsModel
   */
  senderDataAvailabilityMode: DataAvailabilityModes;
  /**
   *
   * @type {DataAvailabilityModes}
   * @memberof TransferDetailsModel
   */
  receiverDataAvailabilityMode: DataAvailabilityModes;
  /**
   * The amount of the asset to be transferred.
   * @type {string}
   * @memberof TransferDetailsModel
   */
  amount: string;
}

/**
 * Request model to transfer assets between users.
 * @export
 * @interface TransferModel
 */
export interface TransferModel {
  /**
   * The unique identifier of the transfer sender vault.
   * @type {string}
   * @memberof TransferModel
   */
  senderVaultId: string;
  /**
   * The unique identifier of the transfer recipient vault.
   * @type {string}
   * @memberof TransferModel
   */
  receiverVaultId: string;
  /**
   * The amount of the asset to be transferred, in quantized form.
   * @type {string}
   * @memberof TransferModel
   */
  quantizedAmount: string;
  /**
   * The timestamp at which this transfer becomes invalid, in seconds since the Unix epoch.
   * @type {number}
   * @memberof TransferModel
   */
  expirationTimestamp: number;
  /**
   * The unique nonce for the transfer.
   * @type {number}
   * @memberof TransferModel
   */
  nonce: number;
  /**
   *
   * @type {SignatureModel}
   * @memberof TransferModel
   */
  signature: SignatureModel;
}
/**
 *
 * @export
 * @interface UserDto
 */
export interface UserDto {
  /**
   * The ID of the user.
   * @type {string}
   * @memberof UserDto
   */
  userId?: string;
  /**
   * The username of the user.
   * @type {string}
   * @memberof UserDto
   */
  username?: string | null;
  /**
   * The STARK key of the user.
   * @type {string}
   * @memberof UserDto
   */
  starkKey?: string | null;
  /**
   * The Ethereum address associated with the user.
   * @type {string}
   * @memberof UserDto
   */
  address?: string | null;
}
/**
 *
 * @export
 * @interface UserDtoPaginatedResponseDto
 */
export interface UserDtoPaginatedResponseDto {
  /**
   * The data in the paginated response.
   * @type {Array<UserDto>}
   * @memberof UserDtoPaginatedResponseDto
   */
  data?: Array<UserDto> | null;
  /**
   *
   * @type {PaginationDto}
   * @memberof UserDtoPaginatedResponseDto
   */
  pagination?: PaginationDto;
  /**
   * The total count of results available.
   * @type {number}
   * @memberof UserDtoPaginatedResponseDto
   */
  totalCount?: number;
}
/**
 *
 * @export
 * @interface UserWithVaultsDto
 */
export interface UserWithVaultsDto {
  /**
   *
   * @type {UserDto}
   * @memberof UserWithVaultsDto
   */
  user?: UserDto;
  /**
   * The user vaults grouped by the asset id.
   * @type {{ [key: string]: Array<VaultDto>; }}
   * @memberof UserWithVaultsDto
   */
  vaultsPerAsset?: { [key: string]: Array<VaultDto> } | null;
}
/**
 *
 * @export
 * @interface VaultDto
 */
export interface VaultDto {
  /**
   * The ID of the vault.
   * @type {string}
   * @memberof VaultDto
   */
  vaultId?: string;
  /**
   * The StarkEx ID of the vault.
   * @type {string}
   * @memberof VaultDto
   */
  vaultChainId?: string;
  /**
   * The address of the StarkEx instance associated with the vault.
   * @type {string}
   * @memberof VaultDto
   */
  starkExAddress?: string | null;
  /**
   * The symbol of the asset associated with the vault.
   * @type {string}
   * @memberof VaultDto
   */
  assetSymbol?: string | null;
  /**
   * The token id of the asset associated with the vault, if the asset is an ERC721 or ERC1155.
   * @type {string}
   * @memberof VaultDto
   */
  tokenId?: string | null;
  /**
   * The minting blob of the asset associated with the vault, if the asset is a Mintable ERC20, ERC721 or ERC1155.
   * @type {string}
   * @memberof VaultDto
   */
  mintingBlob?: string | null;
  /**
   * The StarkEx ID of the asset associated with the vault.
   * @type {string}
   * @memberof VaultDto
   */
  assetStarkExId?: string | null;
  /**
   * The STARK key of the user associated with the vault.
   * @type {string}
   * @memberof VaultDto
   */
  userStarkKey?: string | null;
  /**
   * The available balance of the vault.
   * @type {string}
   * @memberof VaultDto
   */
  availableBalance?: string;
  /**
   * The accounting balance of the vault.
   * @type {string}
   * @memberof VaultDto
   */
  accountingBalance?: string;
  /**
   *
   * @type {DataAvailabilityModes}
   * @memberof VaultDto
   */
  dataAvailabilityMode?: DataAvailabilityModes;
}

/**
 *
 * @export
 * @interface VaultDtoPaginatedResponseDto
 */
export interface VaultDtoPaginatedResponseDto {
  /**
   * The data in the paginated response.
   * @type {Array<VaultDto>}
   * @memberof VaultDtoPaginatedResponseDto
   */
  data?: Array<VaultDto> | null;
  /**
   *
   * @type {PaginationDto}
   * @memberof VaultDtoPaginatedResponseDto
   */
  pagination?: PaginationDto;
  /**
   * The total count of results available.
   * @type {number}
   * @memberof VaultDtoPaginatedResponseDto
   */
  totalCount?: number;
}
/**
 *
 * @export
 * @interface WithdrawDetailsDto
 */
export interface WithdrawDetailsDto {
  /**
   *
   * @type {VaultDto}
   * @memberof WithdrawDetailsDto
   */
  vault?: VaultDto;
  /**
   * The smart contract address that processes on-chain withdraws.
   * @type {string}
   * @memberof WithdrawDetailsDto
   */
  operatorContractAddress?: string | null;
  /**
   * The withdraw function to use on-chain.
   * @type {string}
   * @memberof WithdrawDetailsDto
   */
  withdrawFunction?: string | null;
  /**
   * The user\'s public STARK key
   * @type {string}
   * @memberof WithdrawDetailsDto
   */
  starkKey?: string | null;
  /**
   * The asset type identifier.
   * @type {string}
   * @memberof WithdrawDetailsDto
   */
  assetType?: string | null;
  /**
   * The token Id for ERC-721 and ERC-1155 assets.
   * @type {string}
   * @memberof WithdrawDetailsDto
   */
  tokenId?: string | null;
  /**
   * The minting blob for Mintable ERC-20, ERC-721 and ERC-1155 assets.
   * @type {string}
   * @memberof WithdrawDetailsDto
   */
  mintingBlob?: string | null;
}
/**
 *
 * @export
 * @interface WithdrawModel
 */
export interface WithdrawModel {
  /**
   * The unique identifier of the vault to withdraw from.
   * @type {string}
   * @memberof WithdrawModel
   */
  vaultId: string;
  /**
   * The amount of the asset to be withdrawn, in unquantized form.
   * @type {string}
   * @memberof WithdrawModel
   */
  amount: string;
}

/**
 * AssetApi - axios parameter creator
 * @export
 */
export const AssetApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This endpoint allows for deploying an asset and enable it in the tenant system.
     * @summary Deploy Asset
     * @param {DeployAssetModel} deployAssetModel The asset deployment request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployAsset: async (
      deployAssetModel: DeployAssetModel,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deployAssetModel' is not null or undefined
      assertParamExists('deployAsset', 'deployAssetModel', deployAssetModel);
      const localVarPath = `/api/v1/assets/deploy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        deployAssetModel,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint allows to disable an asset in the tenant system.
     * @summary Disable Asset
     * @param {DisableAssetModel} disableAssetModel The asset disabling request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableAsset: async (
      disableAssetModel: DisableAssetModel,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'disableAssetModel' is not null or undefined
      assertParamExists('disableAsset', 'disableAssetModel', disableAssetModel);
      const localVarPath = `/api/v1/assets/disable`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        disableAssetModel,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint allows to enable an asset in the tenant system.
     * @summary Enable Asset
     * @param {EnableAssetModel} enableAssetModel The asset enabling request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableAsset: async (
      enableAssetModel: EnableAssetModel,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'enableAssetModel' is not null or undefined
      assertParamExists('enableAsset', 'enableAssetModel', enableAssetModel);
      const localVarPath = `/api/v1/assets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        enableAssetModel,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint allows for deploying an asset and enable it in the tenant system.
     * @summary Estimate cost of the deployment for a new Asset
     * @param {AssetType} assetType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateAssetDeployCost: async (
      assetType: AssetType,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'assetType' is not null or undefined
      assertParamExists('estimateAssetDeployCost', 'assetType', assetType);
      const localVarPath = `/api/v1/assets/estimate-deploy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      if (assetType !== undefined) {
        localVarQueryParameter['asset_type'] = assetType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint fetches all assets enabled in the tenant system, with support for filters and pagination.
     * @summary Get All Assets
     * @param {string} [assetId]
     * @param {AssetType} [assetType]
     * @param {FilterOptions} [assetTypeComparison]
     * @param {string} [assetSymbol]
     * @param {FilterOptions} [assetSymbolComparison]
     * @param {number} [pageNumber]
     * @param {number} [pageSize]
     * @param {string} [sortBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllAssets: async (
      assetId?: string,
      assetType?: AssetType,
      assetTypeComparison?: FilterOptions,
      assetSymbol?: string,
      assetSymbolComparison?: FilterOptions,
      pageNumber?: number,
      pageSize?: number,
      sortBy?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/assets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      if (assetId !== undefined) {
        localVarQueryParameter['asset_id'] = assetId;
      }

      if (assetType !== undefined) {
        localVarQueryParameter['asset_type'] = assetType;
      }

      if (assetTypeComparison !== undefined) {
        localVarQueryParameter['asset_type_comparison'] = assetTypeComparison;
      }

      if (assetSymbol !== undefined) {
        localVarQueryParameter['asset_symbol'] = assetSymbol;
      }

      if (assetSymbolComparison !== undefined) {
        localVarQueryParameter['asset_symbol_comparison'] =
          assetSymbolComparison;
      }

      if (pageNumber !== undefined) {
        localVarQueryParameter['page_number'] = pageNumber;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter['sort_by'] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint fetches a specific enabled asset by ID.
     * @summary Get Asset
     * @param {string} assetId The asset ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAsset: async (
      assetId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'assetId' is not null or undefined
      assertParamExists('getAsset', 'assetId', assetId);
      const localVarPath = `/api/v1/assets/{assetId}`.replace(
        `{${'assetId'}}`,
        encodeURIComponent(String(assetId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AssetApi - functional programming interface
 * @export
 */
export const AssetApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AssetApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint allows for deploying an asset and enable it in the tenant system.
     * @summary Deploy Asset
     * @param {DeployAssetModel} deployAssetModel The asset deployment request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deployAsset(
      deployAssetModel: DeployAssetModel,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantAssetDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deployAsset(
        deployAssetModel,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint allows to disable an asset in the tenant system.
     * @summary Disable Asset
     * @param {DisableAssetModel} disableAssetModel The asset disabling request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async disableAsset(
      disableAssetModel: DisableAssetModel,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantAssetDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.disableAsset(
        disableAssetModel,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint allows to enable an asset in the tenant system.
     * @summary Enable Asset
     * @param {EnableAssetModel} enableAssetModel The asset enabling request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async enableAsset(
      enableAssetModel: EnableAssetModel,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantAssetDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.enableAsset(
        enableAssetModel,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint allows for deploying an asset and enable it in the tenant system.
     * @summary Estimate cost of the deployment for a new Asset
     * @param {AssetType} assetType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async estimateAssetDeployCost(
      assetType: AssetType,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantAssetDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.estimateAssetDeployCost(
          assetType,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint fetches all assets enabled in the tenant system, with support for filters and pagination.
     * @summary Get All Assets
     * @param {string} [assetId]
     * @param {AssetType} [assetType]
     * @param {FilterOptions} [assetTypeComparison]
     * @param {string} [assetSymbol]
     * @param {FilterOptions} [assetSymbolComparison]
     * @param {number} [pageNumber]
     * @param {number} [pageSize]
     * @param {string} [sortBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllAssets(
      assetId?: string,
      assetType?: AssetType,
      assetTypeComparison?: FilterOptions,
      assetSymbol?: string,
      assetSymbolComparison?: FilterOptions,
      pageNumber?: number,
      pageSize?: number,
      sortBy?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TenantAssetDtoPaginatedResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAssets(
        assetId,
        assetType,
        assetTypeComparison,
        assetSymbol,
        assetSymbolComparison,
        pageNumber,
        pageSize,
        sortBy,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint fetches a specific enabled asset by ID.
     * @summary Get Asset
     * @param {string} assetId The asset ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAsset(
      assetId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantAssetDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(
        assetId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * AssetApi - factory interface
 * @export
 */
export const AssetApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AssetApiFp(configuration);
  return {
    /**
     * This endpoint allows for deploying an asset and enable it in the tenant system.
     * @summary Deploy Asset
     * @param {DeployAssetModel} deployAssetModel The asset deployment request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployAsset(
      deployAssetModel: DeployAssetModel,
      options?: any,
    ): AxiosPromise<TenantAssetDto> {
      return localVarFp
        .deployAsset(deployAssetModel, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint allows to disable an asset in the tenant system.
     * @summary Disable Asset
     * @param {DisableAssetModel} disableAssetModel The asset disabling request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableAsset(
      disableAssetModel: DisableAssetModel,
      options?: any,
    ): AxiosPromise<TenantAssetDto> {
      return localVarFp
        .disableAsset(disableAssetModel, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint allows to enable an asset in the tenant system.
     * @summary Enable Asset
     * @param {EnableAssetModel} enableAssetModel The asset enabling request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableAsset(
      enableAssetModel: EnableAssetModel,
      options?: any,
    ): AxiosPromise<TenantAssetDto> {
      return localVarFp
        .enableAsset(enableAssetModel, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint allows for deploying an asset and enable it in the tenant system.
     * @summary Estimate cost of the deployment for a new Asset
     * @param {AssetType} assetType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    estimateAssetDeployCost(
      assetType: AssetType,
      options?: any,
    ): AxiosPromise<TenantAssetDto> {
      return localVarFp
        .estimateAssetDeployCost(assetType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint fetches all assets enabled in the tenant system, with support for filters and pagination.
     * @summary Get All Assets
     * @param {string} [assetId]
     * @param {AssetType} [assetType]
     * @param {FilterOptions} [assetTypeComparison]
     * @param {string} [assetSymbol]
     * @param {FilterOptions} [assetSymbolComparison]
     * @param {number} [pageNumber]
     * @param {number} [pageSize]
     * @param {string} [sortBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllAssets(
      assetId?: string,
      assetType?: AssetType,
      assetTypeComparison?: FilterOptions,
      assetSymbol?: string,
      assetSymbolComparison?: FilterOptions,
      pageNumber?: number,
      pageSize?: number,
      sortBy?: string,
      options?: any,
    ): AxiosPromise<TenantAssetDtoPaginatedResponseDto> {
      return localVarFp
        .getAllAssets(
          assetId,
          assetType,
          assetTypeComparison,
          assetSymbol,
          assetSymbolComparison,
          pageNumber,
          pageSize,
          sortBy,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint fetches a specific enabled asset by ID.
     * @summary Get Asset
     * @param {string} assetId The asset ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAsset(assetId: string, options?: any): AxiosPromise<TenantAssetDto> {
      return localVarFp
        .getAsset(assetId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AssetApi - object-oriented interface
 * @export
 * @class AssetApi
 * @extends {BaseAPI}
 */
export class AssetApi extends BaseAPI {
  /**
   * This endpoint allows for deploying an asset and enable it in the tenant system.
   * @summary Deploy Asset
   * @param {DeployAssetModel} deployAssetModel The asset deployment request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetApi
   */
  public deployAsset(
    deployAssetModel: DeployAssetModel,
    options?: AxiosRequestConfig,
  ) {
    return AssetApiFp(this.configuration)
      .deployAsset(deployAssetModel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint allows to disable an asset in the tenant system.
   * @summary Disable Asset
   * @param {DisableAssetModel} disableAssetModel The asset disabling request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetApi
   */
  public disableAsset(
    disableAssetModel: DisableAssetModel,
    options?: AxiosRequestConfig,
  ) {
    return AssetApiFp(this.configuration)
      .disableAsset(disableAssetModel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint allows to enable an asset in the tenant system.
   * @summary Enable Asset
   * @param {EnableAssetModel} enableAssetModel The asset enabling request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetApi
   */
  public enableAsset(
    enableAssetModel: EnableAssetModel,
    options?: AxiosRequestConfig,
  ) {
    return AssetApiFp(this.configuration)
      .enableAsset(enableAssetModel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint allows for deploying an asset and enable it in the tenant system.
   * @summary Estimate cost of the deployment for a new Asset
   * @param {AssetType} assetType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetApi
   */
  public estimateAssetDeployCost(
    assetType: AssetType,
    options?: AxiosRequestConfig,
  ) {
    return AssetApiFp(this.configuration)
      .estimateAssetDeployCost(assetType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint fetches all assets enabled in the tenant system, with support for filters and pagination.
   * @summary Get All Assets
   * @param {string} [assetId]
   * @param {AssetType} [assetType]
   * @param {FilterOptions} [assetTypeComparison]
   * @param {string} [assetSymbol]
   * @param {FilterOptions} [assetSymbolComparison]
   * @param {number} [pageNumber]
   * @param {number} [pageSize]
   * @param {string} [sortBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetApi
   */
  public getAllAssets(
    assetId?: string,
    assetType?: AssetType,
    assetTypeComparison?: FilterOptions,
    assetSymbol?: string,
    assetSymbolComparison?: FilterOptions,
    pageNumber?: number,
    pageSize?: number,
    sortBy?: string,
    options?: AxiosRequestConfig,
  ) {
    return AssetApiFp(this.configuration)
      .getAllAssets(
        assetId,
        assetType,
        assetTypeComparison,
        assetSymbol,
        assetSymbolComparison,
        pageNumber,
        pageSize,
        sortBy,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint fetches a specific enabled asset by ID.
   * @summary Get Asset
   * @param {string} assetId The asset ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetApi
   */
  public getAsset(assetId: string, options?: AxiosRequestConfig) {
    return AssetApiFp(this.configuration)
      .getAsset(assetId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DepositApi - axios parameter creator
 * @export
 */
export const DepositApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This endpoint returns the deposit details for a given user, asset, and data availability mode.
     * @summary Returns the deposit details for a given asset.
     * @param {DepositDetailsModel} depositDetailsModel The deposit details request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    depositDetails: async (
      depositDetailsModel: DepositDetailsModel,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'depositDetailsModel' is not null or undefined
      assertParamExists(
        'depositDetails',
        'depositDetailsModel',
        depositDetailsModel,
      );
      const localVarPath = `/api/v1/vaults/deposit-details`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        depositDetailsModel,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DepositApi - functional programming interface
 * @export
 */
export const DepositApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DepositApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint returns the deposit details for a given user, asset, and data availability mode.
     * @summary Returns the deposit details for a given asset.
     * @param {DepositDetailsModel} depositDetailsModel The deposit details request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async depositDetails(
      depositDetailsModel: DepositDetailsModel,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DepositDetailsDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.depositDetails(
        depositDetailsModel,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * DepositApi - factory interface
 * @export
 */
export const DepositApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DepositApiFp(configuration);
  return {
    /**
     * This endpoint returns the deposit details for a given user, asset, and data availability mode.
     * @summary Returns the deposit details for a given asset.
     * @param {DepositDetailsModel} depositDetailsModel The deposit details request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    depositDetails(
      depositDetailsModel: DepositDetailsModel,
      options?: any,
    ): AxiosPromise<DepositDetailsDto> {
      return localVarFp
        .depositDetails(depositDetailsModel, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DepositApi - object-oriented interface
 * @export
 * @class DepositApi
 * @extends {BaseAPI}
 */
export class DepositApi extends BaseAPI {
  /**
   * This endpoint returns the deposit details for a given user, asset, and data availability mode.
   * @summary Returns the deposit details for a given asset.
   * @param {DepositDetailsModel} depositDetailsModel The deposit details request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DepositApi
   */
  public depositDetails(
    depositDetailsModel: DepositDetailsModel,
    options?: AxiosRequestConfig,
  ) {
    return DepositApiFp(this.configuration)
      .depositDetails(depositDetailsModel, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FeeApi - axios parameter creator
 * @export
 */
export const FeeApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This endpoint allows to configure the fee model for a specific operation.
     * @summary Configure Fee Model
     * @param {ConfigureFeeModel} configureFeeModel The fee model configuration request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    configureFeeModel: async (
      configureFeeModel: ConfigureFeeModel,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configureFeeModel' is not null or undefined
      assertParamExists(
        'configureFeeModel',
        'configureFeeModel',
        configureFeeModel,
      );
      const localVarPath = `/api/v1/fees`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        configureFeeModel,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint fetches a configured operation fee by ID.
     * @summary Get Fee Model
     * @param {string} feeId The fee model configuration ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeeModel: async (
      feeId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'feeId' is not null or undefined
      assertParamExists('getFeeModel', 'feeId', feeId);
      const localVarPath = `/api/v1/fees/{feeId}`.replace(
        `{${'feeId'}}`,
        encodeURIComponent(String(feeId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FeeApi - functional programming interface
 * @export
 */
export const FeeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FeeApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint allows to configure the fee model for a specific operation.
     * @summary Configure Fee Model
     * @param {ConfigureFeeModel} configureFeeModel The fee model configuration request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async configureFeeModel(
      configureFeeModel: ConfigureFeeModel,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeConfigDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.configureFeeModel(
          configureFeeModel,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint fetches a configured operation fee by ID.
     * @summary Get Fee Model
     * @param {string} feeId The fee model configuration ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFeeModel(
      feeId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeConfigDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFeeModel(
        feeId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * FeeApi - factory interface
 * @export
 */
export const FeeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FeeApiFp(configuration);
  return {
    /**
     * This endpoint allows to configure the fee model for a specific operation.
     * @summary Configure Fee Model
     * @param {ConfigureFeeModel} configureFeeModel The fee model configuration request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    configureFeeModel(
      configureFeeModel: ConfigureFeeModel,
      options?: any,
    ): AxiosPromise<FeeConfigDto> {
      return localVarFp
        .configureFeeModel(configureFeeModel, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint fetches a configured operation fee by ID.
     * @summary Get Fee Model
     * @param {string} feeId The fee model configuration ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeeModel(feeId: string, options?: any): AxiosPromise<FeeConfigDto> {
      return localVarFp
        .getFeeModel(feeId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FeeApi - object-oriented interface
 * @export
 * @class FeeApi
 * @extends {BaseAPI}
 */
export class FeeApi extends BaseAPI {
  /**
   * This endpoint allows to configure the fee model for a specific operation.
   * @summary Configure Fee Model
   * @param {ConfigureFeeModel} configureFeeModel The fee model configuration request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeeApi
   */
  public configureFeeModel(
    configureFeeModel: ConfigureFeeModel,
    options?: AxiosRequestConfig,
  ) {
    return FeeApiFp(this.configuration)
      .configureFeeModel(configureFeeModel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint fetches a configured operation fee by ID.
   * @summary Get Fee Model
   * @param {string} feeId The fee model configuration ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeeApi
   */
  public getFeeModel(feeId: string, options?: AxiosRequestConfig) {
    return FeeApiFp(this.configuration)
      .getFeeModel(feeId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MintApi - axios parameter creator
 * @export
 */
export const MintApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This endpoint allows for the minting of fungible and non-fungible assets.
     * @summary Mint Assets
     * @param {BatchMintRequestModel} batchMintRequestModel The assets to mint for each user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintAssets: async (
      batchMintRequestModel: BatchMintRequestModel,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'batchMintRequestModel' is not null or undefined
      assertParamExists(
        'mintAssets',
        'batchMintRequestModel',
        batchMintRequestModel,
      );
      const localVarPath = `/api/v1/mint`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        batchMintRequestModel,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MintApi - functional programming interface
 * @export
 */
export const MintApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MintApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint allows for the minting of fungible and non-fungible assets.
     * @summary Mint Assets
     * @param {BatchMintRequestModel} batchMintRequestModel The assets to mint for each user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mintAssets(
      batchMintRequestModel: BatchMintRequestModel,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<{ [key: string]: Array<VaultDto> }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.mintAssets(
        batchMintRequestModel,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * MintApi - factory interface
 * @export
 */
export const MintApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = MintApiFp(configuration);
  return {
    /**
     * This endpoint allows for the minting of fungible and non-fungible assets.
     * @summary Mint Assets
     * @param {BatchMintRequestModel} batchMintRequestModel The assets to mint for each user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintAssets(
      batchMintRequestModel: BatchMintRequestModel,
      options?: any,
    ): AxiosPromise<{ [key: string]: Array<VaultDto> }> {
      return localVarFp
        .mintAssets(batchMintRequestModel, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MintApi - object-oriented interface
 * @export
 * @class MintApi
 * @extends {BaseAPI}
 */
export class MintApi extends BaseAPI {
  /**
   * This endpoint allows for the minting of fungible and non-fungible assets.
   * @summary Mint Assets
   * @param {BatchMintRequestModel} batchMintRequestModel The assets to mint for each user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MintApi
   */
  public mintAssets(
    batchMintRequestModel: BatchMintRequestModel,
    options?: AxiosRequestConfig,
  ) {
    return MintApiFp(this.configuration)
      .mintAssets(batchMintRequestModel, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This endpoint cancels an active order.
     * @summary Cancel Order (Not Implemented)
     * @param {string} orderId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelOrder: async (
      orderId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'orderId' is not null or undefined
      assertParamExists('cancelOrder', 'orderId', orderId);
      const localVarPath = `/api/v1/orders/{orderId}`.replace(
        `{${'orderId'}}`,
        encodeURIComponent(String(orderId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint allows for fetching details of an order to be signed.
     * @summary Get Order Details (Not Implemented)
     * @param {OrderDetailsModel} orderDetailsModel The signable order details request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    orderDetails: async (
      orderDetailsModel: OrderDetailsModel,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'orderDetailsModel' is not null or undefined
      assertParamExists('orderDetails', 'orderDetailsModel', orderDetailsModel);
      const localVarPath = `/api/v1/orders/details`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        orderDetailsModel,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint submits an order to the matching engine.
     * @summary Submit Order (Not Implemented)
     * @param {SubmitOrderModel} submitOrderModel The order submission request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitOrder: async (
      submitOrderModel: SubmitOrderModel,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'submitOrderModel' is not null or undefined
      assertParamExists('submitOrder', 'submitOrderModel', submitOrderModel);
      const localVarPath = `/api/v1/orders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        submitOrderModel,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint cancels an active order.
     * @summary Cancel Order (Not Implemented)
     * @param {string} orderId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelOrder(
      orderId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrder(
        orderId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint allows for fetching details of an order to be signed.
     * @summary Get Order Details (Not Implemented)
     * @param {OrderDetailsModel} orderDetailsModel The signable order details request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async orderDetails(
      orderDetailsModel: OrderDetailsModel,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OrderDetailsDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.orderDetails(
        orderDetailsModel,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint submits an order to the matching engine.
     * @summary Submit Order (Not Implemented)
     * @param {SubmitOrderModel} submitOrderModel The order submission request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitOrder(
      submitOrderModel: SubmitOrderModel,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.submitOrder(
        submitOrderModel,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = OrderApiFp(configuration);
  return {
    /**
     * This endpoint cancels an active order.
     * @summary Cancel Order (Not Implemented)
     * @param {string} orderId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelOrder(orderId: string, options?: any): AxiosPromise<OrderDto> {
      return localVarFp
        .cancelOrder(orderId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint allows for fetching details of an order to be signed.
     * @summary Get Order Details (Not Implemented)
     * @param {OrderDetailsModel} orderDetailsModel The signable order details request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    orderDetails(
      orderDetailsModel: OrderDetailsModel,
      options?: any,
    ): AxiosPromise<OrderDetailsDto> {
      return localVarFp
        .orderDetails(orderDetailsModel, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint submits an order to the matching engine.
     * @summary Submit Order (Not Implemented)
     * @param {SubmitOrderModel} submitOrderModel The order submission request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitOrder(
      submitOrderModel: SubmitOrderModel,
      options?: any,
    ): AxiosPromise<OrderDto> {
      return localVarFp
        .submitOrder(submitOrderModel, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
  /**
   * This endpoint cancels an active order.
   * @summary Cancel Order (Not Implemented)
   * @param {string} orderId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public cancelOrder(orderId: string, options?: AxiosRequestConfig) {
    return OrderApiFp(this.configuration)
      .cancelOrder(orderId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint allows for fetching details of an order to be signed.
   * @summary Get Order Details (Not Implemented)
   * @param {OrderDetailsModel} orderDetailsModel The signable order details request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public orderDetails(
    orderDetailsModel: OrderDetailsModel,
    options?: AxiosRequestConfig,
  ) {
    return OrderApiFp(this.configuration)
      .orderDetails(orderDetailsModel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint submits an order to the matching engine.
   * @summary Submit Order (Not Implemented)
   * @param {SubmitOrderModel} submitOrderModel The order submission request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public submitOrder(
    submitOrderModel: SubmitOrderModel,
    options?: AxiosRequestConfig,
  ) {
    return OrderApiFp(this.configuration)
      .submitOrder(submitOrderModel, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * OrderbookApi - axios parameter creator
 * @export
 */
export const OrderbookApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This endpoint creates an orderbook.
     * @summary Create Orderbook (Not Implemented)
     * @param {CreateOrderbookModel} createOrderbookModel The orderbook creation request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrderbook: async (
      createOrderbookModel: CreateOrderbookModel,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createOrderbookModel' is not null or undefined
      assertParamExists(
        'createOrderbook',
        'createOrderbookModel',
        createOrderbookModel,
      );
      const localVarPath = `/api/v1/orderbooks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createOrderbookModel,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint fetches orderbook metadata by ID.
     * @summary Get Orderbook (Not Implemented)
     * @param {string} orderbookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrderbook: async (
      orderbookId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'orderbookId' is not null or undefined
      assertParamExists('getOrderbook', 'orderbookId', orderbookId);
      const localVarPath = `/api/v1/orderbooks/{orderbookId}`.replace(
        `{${'orderbookId'}}`,
        encodeURIComponent(String(orderbookId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint fetches orderbook level 1 data by ID.
     * @summary Get Orderbook L1 Data (Not Implemented)
     * @param {string} orderbookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrderbookLevel1Data: async (
      orderbookId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'orderbookId' is not null or undefined
      assertParamExists('getOrderbookLevel1Data', 'orderbookId', orderbookId);
      const localVarPath = `/api/v1/orderbooks/{orderbookId}/l1`.replace(
        `{${'orderbookId'}}`,
        encodeURIComponent(String(orderbookId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint fetches orderbook level 2 data by ID.
     * @summary Get Orderbook L2 Data (Not Implemented)
     * @param {string} orderbookId
     * @param {number} [depth]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrderbookLevel2Data: async (
      orderbookId: string,
      depth?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'orderbookId' is not null or undefined
      assertParamExists('getOrderbookLevel2Data', 'orderbookId', orderbookId);
      const localVarPath = `/api/v1/orderbooks/{orderbookId}/l2`.replace(
        `{${'orderbookId'}}`,
        encodeURIComponent(String(orderbookId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (depth !== undefined) {
        localVarQueryParameter['depth'] = depth;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OrderbookApi - functional programming interface
 * @export
 */
export const OrderbookApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    OrderbookApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint creates an orderbook.
     * @summary Create Orderbook (Not Implemented)
     * @param {CreateOrderbookModel} createOrderbookModel The orderbook creation request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOrderbook(
      createOrderbookModel: CreateOrderbookModel,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderbookDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderbook(
        createOrderbookModel,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint fetches orderbook metadata by ID.
     * @summary Get Orderbook (Not Implemented)
     * @param {string} orderbookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOrderbook(
      orderbookId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderbookDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderbook(
        orderbookId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint fetches orderbook level 1 data by ID.
     * @summary Get Orderbook L1 Data (Not Implemented)
     * @param {string} orderbookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOrderbookLevel1Data(
      orderbookId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OrderbookLevel1DataDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOrderbookLevel1Data(
          orderbookId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint fetches orderbook level 2 data by ID.
     * @summary Get Orderbook L2 Data (Not Implemented)
     * @param {string} orderbookId
     * @param {number} [depth]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOrderbookLevel2Data(
      orderbookId: string,
      depth?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OrderbookLevel2DataDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOrderbookLevel2Data(
          orderbookId,
          depth,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * OrderbookApi - factory interface
 * @export
 */
export const OrderbookApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = OrderbookApiFp(configuration);
  return {
    /**
     * This endpoint creates an orderbook.
     * @summary Create Orderbook (Not Implemented)
     * @param {CreateOrderbookModel} createOrderbookModel The orderbook creation request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrderbook(
      createOrderbookModel: CreateOrderbookModel,
      options?: any,
    ): AxiosPromise<OrderbookDto> {
      return localVarFp
        .createOrderbook(createOrderbookModel, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint fetches orderbook metadata by ID.
     * @summary Get Orderbook (Not Implemented)
     * @param {string} orderbookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrderbook(
      orderbookId: string,
      options?: any,
    ): AxiosPromise<OrderbookDto> {
      return localVarFp
        .getOrderbook(orderbookId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint fetches orderbook level 1 data by ID.
     * @summary Get Orderbook L1 Data (Not Implemented)
     * @param {string} orderbookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrderbookLevel1Data(
      orderbookId: string,
      options?: any,
    ): AxiosPromise<OrderbookLevel1DataDto> {
      return localVarFp
        .getOrderbookLevel1Data(orderbookId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint fetches orderbook level 2 data by ID.
     * @summary Get Orderbook L2 Data (Not Implemented)
     * @param {string} orderbookId
     * @param {number} [depth]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrderbookLevel2Data(
      orderbookId: string,
      depth?: number,
      options?: any,
    ): AxiosPromise<OrderbookLevel2DataDto> {
      return localVarFp
        .getOrderbookLevel2Data(orderbookId, depth, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * OrderbookApi - object-oriented interface
 * @export
 * @class OrderbookApi
 * @extends {BaseAPI}
 */
export class OrderbookApi extends BaseAPI {
  /**
   * This endpoint creates an orderbook.
   * @summary Create Orderbook (Not Implemented)
   * @param {CreateOrderbookModel} createOrderbookModel The orderbook creation request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderbookApi
   */
  public createOrderbook(
    createOrderbookModel: CreateOrderbookModel,
    options?: AxiosRequestConfig,
  ) {
    return OrderbookApiFp(this.configuration)
      .createOrderbook(createOrderbookModel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint fetches orderbook metadata by ID.
   * @summary Get Orderbook (Not Implemented)
   * @param {string} orderbookId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderbookApi
   */
  public getOrderbook(orderbookId: string, options?: AxiosRequestConfig) {
    return OrderbookApiFp(this.configuration)
      .getOrderbook(orderbookId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint fetches orderbook level 1 data by ID.
   * @summary Get Orderbook L1 Data (Not Implemented)
   * @param {string} orderbookId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderbookApi
   */
  public getOrderbookLevel1Data(
    orderbookId: string,
    options?: AxiosRequestConfig,
  ) {
    return OrderbookApiFp(this.configuration)
      .getOrderbookLevel1Data(orderbookId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint fetches orderbook level 2 data by ID.
   * @summary Get Orderbook L2 Data (Not Implemented)
   * @param {string} orderbookId
   * @param {number} [depth]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderbookApi
   */
  public getOrderbookLevel2Data(
    orderbookId: string,
    depth?: number,
    options?: AxiosRequestConfig,
  ) {
    return OrderbookApiFp(this.configuration)
      .getOrderbookLevel2Data(orderbookId, depth, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SettlementApi - axios parameter creator
 * @export
 */
export const SettlementApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This endpoint submits an order settlement.
     * @summary Submit Settlement
     * @param {SubmitSettlementModel} submitSettlementModel The settlement request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitSettlement: async (
      submitSettlementModel: SubmitSettlementModel,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'submitSettlementModel' is not null or undefined
      assertParamExists(
        'submitSettlement',
        'submitSettlementModel',
        submitSettlementModel,
      );
      const localVarPath = `/api/v1/settlements`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        submitSettlementModel,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SettlementApi - functional programming interface
 * @export
 */
export const SettlementApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SettlementApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint submits an order settlement.
     * @summary Submit Settlement
     * @param {SubmitSettlementModel} submitSettlementModel The settlement request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitSettlement(
      submitSettlementModel: SubmitSettlementModel,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<VaultDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.submitSettlement(
          submitSettlementModel,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * SettlementApi - factory interface
 * @export
 */
export const SettlementApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SettlementApiFp(configuration);
  return {
    /**
     * This endpoint submits an order settlement.
     * @summary Submit Settlement
     * @param {SubmitSettlementModel} submitSettlementModel The settlement request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitSettlement(
      submitSettlementModel: SubmitSettlementModel,
      options?: any,
    ): AxiosPromise<Array<VaultDto>> {
      return localVarFp
        .submitSettlement(submitSettlementModel, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SettlementApi - object-oriented interface
 * @export
 * @class SettlementApi
 * @extends {BaseAPI}
 */
export class SettlementApi extends BaseAPI {
  /**
   * This endpoint submits an order settlement.
   * @summary Submit Settlement
   * @param {SubmitSettlementModel} submitSettlementModel The settlement request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettlementApi
   */
  public submitSettlement(
    submitSettlementModel: SubmitSettlementModel,
    options?: AxiosRequestConfig,
  ) {
    return SettlementApiFp(this.configuration)
      .submitSettlement(submitSettlementModel, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This endpoint fetches all transactions submitted by the system, with support for filters and pagination.
     * @summary Get All Transactions
     * @param {TransactionStatus} [transactionStatus]
     * @param {FilterOptions} [transactionStatusComparison]
     * @param {number} [starkexTxId]
     * @param {FilterOptions} [starkexTxIdComparison]
     * @param {StarkExOperation} [txType]
     * @param {FilterOptions} [txTypeComparison]
     * @param {number} [pageNumber]
     * @param {number} [pageSize]
     * @param {string} [sortBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTransactions: async (
      transactionStatus?: TransactionStatus,
      transactionStatusComparison?: FilterOptions,
      starkexTxId?: number,
      starkexTxIdComparison?: FilterOptions,
      txType?: StarkExOperation,
      txTypeComparison?: FilterOptions,
      pageNumber?: number,
      pageSize?: number,
      sortBy?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/transactions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      if (transactionStatus !== undefined) {
        localVarQueryParameter['transaction_status'] = transactionStatus;
      }

      if (transactionStatusComparison !== undefined) {
        localVarQueryParameter['transaction_status_comparison'] =
          transactionStatusComparison;
      }

      if (starkexTxId !== undefined) {
        localVarQueryParameter['starkex_tx_id'] = starkexTxId;
      }

      if (starkexTxIdComparison !== undefined) {
        localVarQueryParameter['starkex_tx_id_comparison'] =
          starkexTxIdComparison;
      }

      if (txType !== undefined) {
        localVarQueryParameter['tx_type'] = txType;
      }

      if (txTypeComparison !== undefined) {
        localVarQueryParameter['tx_type_comparison'] = txTypeComparison;
      }

      if (pageNumber !== undefined) {
        localVarQueryParameter['page_number'] = pageNumber;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter['sort_by'] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint fetches a specific transaction by ID.
     * @summary Get Transaction
     * @param {string} transactionId The transaction ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction: async (
      transactionId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'transactionId' is not null or undefined
      assertParamExists('getTransaction', 'transactionId', transactionId);
      const localVarPath = `/api/v1/transactions/{transactionId}`.replace(
        `{${'transactionId'}}`,
        encodeURIComponent(String(transactionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint allows the client to render plots (time series) of the transactions costs.
     * @summary Get transactions costs
     * @param {StarkExOperation} [transactionType]
     * @param {string} [startDate]
     * @param {string} [endDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionCosts: async (
      transactionType?: StarkExOperation,
      startDate?: string,
      endDate?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/transactions/time-series/costs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      if (transactionType !== undefined) {
        localVarQueryParameter['transaction_type'] = transactionType;
      }

      if (startDate !== undefined) {
        localVarQueryParameter['start_date'] = startDate;
      }

      if (endDate !== undefined) {
        localVarQueryParameter['end_date'] = endDate;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint allows the client to render plots (time series) of the transactions throughput by type.
     * @summary Get transactions throughput by type
     * @param {StarkExOperation} [transactionType]
     * @param {string} [startDate]
     * @param {string} [endDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionThroughput: async (
      transactionType?: StarkExOperation,
      startDate?: string,
      endDate?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/transactions/time-series`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      if (transactionType !== undefined) {
        localVarQueryParameter['transaction_type'] = transactionType;
      }

      if (startDate !== undefined) {
        localVarQueryParameter['start_date'] = startDate;
      }

      if (endDate !== undefined) {
        localVarQueryParameter['end_date'] = endDate;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TransactionApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint fetches all transactions submitted by the system, with support for filters and pagination.
     * @summary Get All Transactions
     * @param {TransactionStatus} [transactionStatus]
     * @param {FilterOptions} [transactionStatusComparison]
     * @param {number} [starkexTxId]
     * @param {FilterOptions} [starkexTxIdComparison]
     * @param {StarkExOperation} [txType]
     * @param {FilterOptions} [txTypeComparison]
     * @param {number} [pageNumber]
     * @param {number} [pageSize]
     * @param {string} [sortBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllTransactions(
      transactionStatus?: TransactionStatus,
      transactionStatusComparison?: FilterOptions,
      starkexTxId?: number,
      starkexTxIdComparison?: FilterOptions,
      txType?: StarkExOperation,
      txTypeComparison?: FilterOptions,
      pageNumber?: number,
      pageSize?: number,
      sortBy?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TransactionDtoPaginatedResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllTransactions(
          transactionStatus,
          transactionStatusComparison,
          starkexTxId,
          starkexTxIdComparison,
          txType,
          txTypeComparison,
          pageNumber,
          pageSize,
          sortBy,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint fetches a specific transaction by ID.
     * @summary Get Transaction
     * @param {string} transactionId The transaction ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransaction(
      transactionId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTransaction(
        transactionId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint allows the client to render plots (time series) of the transactions costs.
     * @summary Get transactions costs
     * @param {StarkExOperation} [transactionType]
     * @param {string} [startDate]
     * @param {string} [endDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransactionCosts(
      transactionType?: StarkExOperation,
      startDate?: string,
      endDate?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TimeSeriesCostsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTransactionCosts(
          transactionType,
          startDate,
          endDate,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint allows the client to render plots (time series) of the transactions throughput by type.
     * @summary Get transactions throughput by type
     * @param {StarkExOperation} [transactionType]
     * @param {string} [startDate]
     * @param {string} [endDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransactionThroughput(
      transactionType?: StarkExOperation,
      startDate?: string,
      endDate?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TimeSeriesResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTransactionThroughput(
          transactionType,
          startDate,
          endDate,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TransactionApiFp(configuration);
  return {
    /**
     * This endpoint fetches all transactions submitted by the system, with support for filters and pagination.
     * @summary Get All Transactions
     * @param {TransactionStatus} [transactionStatus]
     * @param {FilterOptions} [transactionStatusComparison]
     * @param {number} [starkexTxId]
     * @param {FilterOptions} [starkexTxIdComparison]
     * @param {StarkExOperation} [txType]
     * @param {FilterOptions} [txTypeComparison]
     * @param {number} [pageNumber]
     * @param {number} [pageSize]
     * @param {string} [sortBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTransactions(
      transactionStatus?: TransactionStatus,
      transactionStatusComparison?: FilterOptions,
      starkexTxId?: number,
      starkexTxIdComparison?: FilterOptions,
      txType?: StarkExOperation,
      txTypeComparison?: FilterOptions,
      pageNumber?: number,
      pageSize?: number,
      sortBy?: string,
      options?: any,
    ): AxiosPromise<TransactionDtoPaginatedResponseDto> {
      return localVarFp
        .getAllTransactions(
          transactionStatus,
          transactionStatusComparison,
          starkexTxId,
          starkexTxIdComparison,
          txType,
          txTypeComparison,
          pageNumber,
          pageSize,
          sortBy,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint fetches a specific transaction by ID.
     * @summary Get Transaction
     * @param {string} transactionId The transaction ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(
      transactionId: string,
      options?: any,
    ): AxiosPromise<TransactionDto> {
      return localVarFp
        .getTransaction(transactionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint allows the client to render plots (time series) of the transactions costs.
     * @summary Get transactions costs
     * @param {StarkExOperation} [transactionType]
     * @param {string} [startDate]
     * @param {string} [endDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionCosts(
      transactionType?: StarkExOperation,
      startDate?: string,
      endDate?: string,
      options?: any,
    ): AxiosPromise<TimeSeriesCostsResponseDto> {
      return localVarFp
        .getTransactionCosts(transactionType, startDate, endDate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint allows the client to render plots (time series) of the transactions throughput by type.
     * @summary Get transactions throughput by type
     * @param {StarkExOperation} [transactionType]
     * @param {string} [startDate]
     * @param {string} [endDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionThroughput(
      transactionType?: StarkExOperation,
      startDate?: string,
      endDate?: string,
      options?: any,
    ): AxiosPromise<TimeSeriesResponseDto> {
      return localVarFp
        .getTransactionThroughput(transactionType, startDate, endDate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI {
  /**
   * This endpoint fetches all transactions submitted by the system, with support for filters and pagination.
   * @summary Get All Transactions
   * @param {TransactionStatus} [transactionStatus]
   * @param {FilterOptions} [transactionStatusComparison]
   * @param {number} [starkexTxId]
   * @param {FilterOptions} [starkexTxIdComparison]
   * @param {StarkExOperation} [txType]
   * @param {FilterOptions} [txTypeComparison]
   * @param {number} [pageNumber]
   * @param {number} [pageSize]
   * @param {string} [sortBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApi
   */
  public getAllTransactions(
    transactionStatus?: TransactionStatus,
    transactionStatusComparison?: FilterOptions,
    starkexTxId?: number,
    starkexTxIdComparison?: FilterOptions,
    txType?: StarkExOperation,
    txTypeComparison?: FilterOptions,
    pageNumber?: number,
    pageSize?: number,
    sortBy?: string,
    options?: AxiosRequestConfig,
  ) {
    return TransactionApiFp(this.configuration)
      .getAllTransactions(
        transactionStatus,
        transactionStatusComparison,
        starkexTxId,
        starkexTxIdComparison,
        txType,
        txTypeComparison,
        pageNumber,
        pageSize,
        sortBy,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint fetches a specific transaction by ID.
   * @summary Get Transaction
   * @param {string} transactionId The transaction ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApi
   */
  public getTransaction(transactionId: string, options?: AxiosRequestConfig) {
    return TransactionApiFp(this.configuration)
      .getTransaction(transactionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint allows the client to render plots (time series) of the transactions costs.
   * @summary Get transactions costs
   * @param {StarkExOperation} [transactionType]
   * @param {string} [startDate]
   * @param {string} [endDate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApi
   */
  public getTransactionCosts(
    transactionType?: StarkExOperation,
    startDate?: string,
    endDate?: string,
    options?: AxiosRequestConfig,
  ) {
    return TransactionApiFp(this.configuration)
      .getTransactionCosts(transactionType, startDate, endDate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint allows the client to render plots (time series) of the transactions throughput by type.
   * @summary Get transactions throughput by type
   * @param {StarkExOperation} [transactionType]
   * @param {string} [startDate]
   * @param {string} [endDate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApi
   */
  public getTransactionThroughput(
    transactionType?: StarkExOperation,
    startDate?: string,
    endDate?: string,
    options?: AxiosRequestConfig,
  ) {
    return TransactionApiFp(this.configuration)
      .getTransactionThroughput(transactionType, startDate, endDate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TransferApi - axios parameter creator
 * @export
 */
export const TransferApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This endpoint allows for transferring assets between users.
     * @summary Transfer Asset
     * @param {TransferModel} transferModel The transfer request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transfer: async (
      transferModel: TransferModel,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'transferModel' is not null or undefined
      assertParamExists('transfer', 'transferModel', transferModel);
      const localVarPath = `/api/v1/transfers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        transferModel,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint allows for fetching details of a transfer to be signed (allocates a vault for the receiver)
     * @summary Get Transfer Details
     * @param {TransferDetailsModel} transferDetailsModel The signable transfer details request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferDetails: async (
      transferDetailsModel: TransferDetailsModel,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'transferDetailsModel' is not null or undefined
      assertParamExists(
        'transferDetails',
        'transferDetailsModel',
        transferDetailsModel,
      );
      const localVarPath = `/api/v1/transfers/details`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        transferDetailsModel,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TransferApi - functional programming interface
 * @export
 */
export const TransferApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TransferApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint allows for transferring assets between users.
     * @summary Transfer Asset
     * @param {TransferModel} transferModel The transfer request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transfer(
      transferModel: TransferModel,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<VaultDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.transfer(
        transferModel,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint allows for fetching details of a transfer to be signed (allocates a vault for the receiver)
     * @summary Get Transfer Details
     * @param {TransferDetailsModel} transferDetailsModel The signable transfer details request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transferDetails(
      transferDetailsModel: TransferDetailsModel,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TransferDetailsDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.transferDetails(
        transferDetailsModel,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * TransferApi - factory interface
 * @export
 */
export const TransferApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TransferApiFp(configuration);
  return {
    /**
     * This endpoint allows for transferring assets between users.
     * @summary Transfer Asset
     * @param {TransferModel} transferModel The transfer request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transfer(
      transferModel: TransferModel,
      options?: any,
    ): AxiosPromise<Array<VaultDto>> {
      return localVarFp
        .transfer(transferModel, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint allows for fetching details of a transfer to be signed (allocates a vault for the receiver)
     * @summary Get Transfer Details
     * @param {TransferDetailsModel} transferDetailsModel The signable transfer details request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferDetails(
      transferDetailsModel: TransferDetailsModel,
      options?: any,
    ): AxiosPromise<TransferDetailsDto> {
      return localVarFp
        .transferDetails(transferDetailsModel, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TransferApi - object-oriented interface
 * @export
 * @class TransferApi
 * @extends {BaseAPI}
 */
export class TransferApi extends BaseAPI {
  /**
   * This endpoint allows for transferring assets between users.
   * @summary Transfer Asset
   * @param {TransferModel} transferModel The transfer request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransferApi
   */
  public transfer(transferModel: TransferModel, options?: AxiosRequestConfig) {
    return TransferApiFp(this.configuration)
      .transfer(transferModel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint allows for fetching details of a transfer to be signed (allocates a vault for the receiver)
   * @summary Get Transfer Details
   * @param {TransferDetailsModel} transferDetailsModel The signable transfer details request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransferApi
   */
  public transferDetails(
    transferDetailsModel: TransferDetailsModel,
    options?: AxiosRequestConfig,
  ) {
    return TransferApiFp(this.configuration)
      .transferDetails(transferDetailsModel, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This endpoint return the typed data to be signed with EIP712 that is used on user registration.
     * @summary Get EIP712 data to be signed
     * @param {string} username
     * @param {string} starkKey
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eIP712Details: async (
      username: string,
      starkKey: string,
      address: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('eIP712Details', 'username', username);
      // verify required parameter 'starkKey' is not null or undefined
      assertParamExists('eIP712Details', 'starkKey', starkKey);
      // verify required parameter 'address' is not null or undefined
      assertParamExists('eIP712Details', 'address', address);
      const localVarPath = `/api/v1/users/register-details`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      if (username !== undefined) {
        localVarQueryParameter['username'] = username;
      }

      if (starkKey !== undefined) {
        localVarQueryParameter['stark_key'] = starkKey;
      }

      if (address !== undefined) {
        localVarQueryParameter['address'] = address;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint fetches all users.
     * @summary Get All Users
     * @param {string} [username]
     * @param {FilterOptions} [usernameComparison]
     * @param {string} [address]
     * @param {string} [creationDate]
     * @param {FilterOptions} [creationDateComparison]
     * @param {number} [pageNumber]
     * @param {number} [pageSize]
     * @param {string} [sortBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsers: async (
      username?: string,
      usernameComparison?: FilterOptions,
      address?: string,
      creationDate?: string,
      creationDateComparison?: FilterOptions,
      pageNumber?: number,
      pageSize?: number,
      sortBy?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      if (username !== undefined) {
        localVarQueryParameter['username'] = username;
      }

      if (usernameComparison !== undefined) {
        localVarQueryParameter['username_comparison'] = usernameComparison;
      }

      if (address !== undefined) {
        localVarQueryParameter['address'] = address;
      }

      if (creationDate !== undefined) {
        localVarQueryParameter['creation_date'] = creationDate;
      }

      if (creationDateComparison !== undefined) {
        localVarQueryParameter['creation_date_comparison'] =
          creationDateComparison;
      }

      if (pageNumber !== undefined) {
        localVarQueryParameter['page_number'] = pageNumber;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter['sort_by'] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint fetches a specific user by ID.
     * @summary Get User
     * @param {string} userId The user id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (
      userId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getUser', 'userId', userId);
      const localVarPath = `/api/v1/users/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint registers a user.
     * @summary Register new User
     * @param {RegisterUserModel} registerUserModel The user registration request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser: async (
      registerUserModel: RegisterUserModel,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'registerUserModel' is not null or undefined
      assertParamExists('registerUser', 'registerUserModel', registerUserModel);
      const localVarPath = `/api/v1/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        registerUserModel,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint return the typed data to be signed with EIP712 that is used on user registration.
     * @summary Get EIP712 data to be signed
     * @param {string} username
     * @param {string} starkKey
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eIP712Details(
      username: string,
      starkKey: string,
      address: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<RegisterDetailsDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.eIP712Details(
        username,
        starkKey,
        address,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint fetches all users.
     * @summary Get All Users
     * @param {string} [username]
     * @param {FilterOptions} [usernameComparison]
     * @param {string} [address]
     * @param {string} [creationDate]
     * @param {FilterOptions} [creationDateComparison]
     * @param {number} [pageNumber]
     * @param {number} [pageSize]
     * @param {string} [sortBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllUsers(
      username?: string,
      usernameComparison?: FilterOptions,
      address?: string,
      creationDate?: string,
      creationDateComparison?: FilterOptions,
      pageNumber?: number,
      pageSize?: number,
      sortBy?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserDtoPaginatedResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(
        username,
        usernameComparison,
        address,
        creationDate,
        creationDateComparison,
        pageNumber,
        pageSize,
        sortBy,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint fetches a specific user by ID.
     * @summary Get User
     * @param {string} userId The user id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      userId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserWithVaultsDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(
        userId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint registers a user.
     * @summary Register new User
     * @param {RegisterUserModel} registerUserModel The user registration request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async registerUser(
      registerUserModel: RegisterUserModel,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(
        registerUserModel,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     * This endpoint return the typed data to be signed with EIP712 that is used on user registration.
     * @summary Get EIP712 data to be signed
     * @param {string} username
     * @param {string} starkKey
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eIP712Details(
      username: string,
      starkKey: string,
      address: string,
      options?: any,
    ): AxiosPromise<RegisterDetailsDto> {
      return localVarFp
        .eIP712Details(username, starkKey, address, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint fetches all users.
     * @summary Get All Users
     * @param {string} [username]
     * @param {FilterOptions} [usernameComparison]
     * @param {string} [address]
     * @param {string} [creationDate]
     * @param {FilterOptions} [creationDateComparison]
     * @param {number} [pageNumber]
     * @param {number} [pageSize]
     * @param {string} [sortBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsers(
      username?: string,
      usernameComparison?: FilterOptions,
      address?: string,
      creationDate?: string,
      creationDateComparison?: FilterOptions,
      pageNumber?: number,
      pageSize?: number,
      sortBy?: string,
      options?: any,
    ): AxiosPromise<UserDtoPaginatedResponseDto> {
      return localVarFp
        .getAllUsers(
          username,
          usernameComparison,
          address,
          creationDate,
          creationDateComparison,
          pageNumber,
          pageSize,
          sortBy,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint fetches a specific user by ID.
     * @summary Get User
     * @param {string} userId The user id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(userId: string, options?: any): AxiosPromise<UserWithVaultsDto> {
      return localVarFp
        .getUser(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint registers a user.
     * @summary Register new User
     * @param {RegisterUserModel} registerUserModel The user registration request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser(
      registerUserModel: RegisterUserModel,
      options?: any,
    ): AxiosPromise<UserDto> {
      return localVarFp
        .registerUser(registerUserModel, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   * This endpoint return the typed data to be signed with EIP712 that is used on user registration.
   * @summary Get EIP712 data to be signed
   * @param {string} username
   * @param {string} starkKey
   * @param {string} address
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public eIP712Details(
    username: string,
    starkKey: string,
    address: string,
    options?: AxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .eIP712Details(username, starkKey, address, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint fetches all users.
   * @summary Get All Users
   * @param {string} [username]
   * @param {FilterOptions} [usernameComparison]
   * @param {string} [address]
   * @param {string} [creationDate]
   * @param {FilterOptions} [creationDateComparison]
   * @param {number} [pageNumber]
   * @param {number} [pageSize]
   * @param {string} [sortBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getAllUsers(
    username?: string,
    usernameComparison?: FilterOptions,
    address?: string,
    creationDate?: string,
    creationDateComparison?: FilterOptions,
    pageNumber?: number,
    pageSize?: number,
    sortBy?: string,
    options?: AxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .getAllUsers(
        username,
        usernameComparison,
        address,
        creationDate,
        creationDateComparison,
        pageNumber,
        pageSize,
        sortBy,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint fetches a specific user by ID.
   * @summary Get User
   * @param {string} userId The user id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUser(userId: string, options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getUser(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint registers a user.
   * @summary Register new User
   * @param {RegisterUserModel} registerUserModel The user registration request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public registerUser(
    registerUserModel: RegisterUserModel,
    options?: AxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .registerUser(registerUserModel, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * VaultApi - axios parameter creator
 * @export
 */
export const VaultApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This endpoint allocates a new vault for a given asset, if there isn\'t one already allocated.
     * @summary Allocate vault
     * @param {AllocateVaultModel} [allocateVaultModel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    allocateVault: async (
      allocateVaultModel?: AllocateVaultModel,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/vaults`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        allocateVaultModel,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint fetches all vaults in the system, with support for filters and pagination.
     * @summary Get All Vaults
     * @param {string} [assetId]
     * @param {number} [pageNumber]
     * @param {number} [pageSize]
     * @param {string} [sortBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllVaults: async (
      assetId?: string,
      pageNumber?: number,
      pageSize?: number,
      sortBy?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/vaults`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      if (assetId !== undefined) {
        localVarQueryParameter['asset_id'] = assetId;
      }

      if (pageNumber !== undefined) {
        localVarQueryParameter['page_number'] = pageNumber;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter['sort_by'] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint fetches a vault identified by its unique id.
     * @summary Get a single Vault
     * @param {string} vaultId The vault id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVault: async (
      vaultId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'vaultId' is not null or undefined
      assertParamExists('getVault', 'vaultId', vaultId);
      const localVarPath = `/api/v1/vaults/{vaultId}`.replace(
        `{${'vaultId'}}`,
        encodeURIComponent(String(vaultId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VaultApi - functional programming interface
 * @export
 */
export const VaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VaultApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint allocates a new vault for a given asset, if there isn\'t one already allocated.
     * @summary Allocate vault
     * @param {AllocateVaultModel} [allocateVaultModel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async allocateVault(
      allocateVaultModel?: AllocateVaultModel,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.allocateVault(
        allocateVaultModel,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint fetches all vaults in the system, with support for filters and pagination.
     * @summary Get All Vaults
     * @param {string} [assetId]
     * @param {number} [pageNumber]
     * @param {number} [pageSize]
     * @param {string} [sortBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllVaults(
      assetId?: string,
      pageNumber?: number,
      pageSize?: number,
      sortBy?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<VaultDtoPaginatedResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllVaults(
        assetId,
        pageNumber,
        pageSize,
        sortBy,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * This endpoint fetches a vault identified by its unique id.
     * @summary Get a single Vault
     * @param {string} vaultId The vault id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVault(
      vaultId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVault(
        vaultId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * VaultApi - factory interface
 * @export
 */
export const VaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = VaultApiFp(configuration);
  return {
    /**
     * This endpoint allocates a new vault for a given asset, if there isn\'t one already allocated.
     * @summary Allocate vault
     * @param {AllocateVaultModel} [allocateVaultModel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    allocateVault(
      allocateVaultModel?: AllocateVaultModel,
      options?: any,
    ): AxiosPromise<VaultDto> {
      return localVarFp
        .allocateVault(allocateVaultModel, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint fetches all vaults in the system, with support for filters and pagination.
     * @summary Get All Vaults
     * @param {string} [assetId]
     * @param {number} [pageNumber]
     * @param {number} [pageSize]
     * @param {string} [sortBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllVaults(
      assetId?: string,
      pageNumber?: number,
      pageSize?: number,
      sortBy?: string,
      options?: any,
    ): AxiosPromise<VaultDtoPaginatedResponseDto> {
      return localVarFp
        .getAllVaults(assetId, pageNumber, pageSize, sortBy, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint fetches a vault identified by its unique id.
     * @summary Get a single Vault
     * @param {string} vaultId The vault id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVault(vaultId: string, options?: any): AxiosPromise<VaultDto> {
      return localVarFp
        .getVault(vaultId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * VaultApi - object-oriented interface
 * @export
 * @class VaultApi
 * @extends {BaseAPI}
 */
export class VaultApi extends BaseAPI {
  /**
   * This endpoint allocates a new vault for a given asset, if there isn\'t one already allocated.
   * @summary Allocate vault
   * @param {AllocateVaultModel} [allocateVaultModel]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VaultApi
   */
  public allocateVault(
    allocateVaultModel?: AllocateVaultModel,
    options?: AxiosRequestConfig,
  ) {
    return VaultApiFp(this.configuration)
      .allocateVault(allocateVaultModel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint fetches all vaults in the system, with support for filters and pagination.
   * @summary Get All Vaults
   * @param {string} [assetId]
   * @param {number} [pageNumber]
   * @param {number} [pageSize]
   * @param {string} [sortBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VaultApi
   */
  public getAllVaults(
    assetId?: string,
    pageNumber?: number,
    pageSize?: number,
    sortBy?: string,
    options?: AxiosRequestConfig,
  ) {
    return VaultApiFp(this.configuration)
      .getAllVaults(assetId, pageNumber, pageSize, sortBy, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint fetches a vault identified by its unique id.
   * @summary Get a single Vault
   * @param {string} vaultId The vault id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VaultApi
   */
  public getVault(vaultId: string, options?: AxiosRequestConfig) {
    return VaultApiFp(this.configuration)
      .getVault(vaultId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WithdrawApi - axios parameter creator
 * @export
 */
export const WithdrawApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This endpoint allows for withdrawing assets from StarkExpress.
     * @summary Withdraw Asset
     * @param {WithdrawModel} withdrawModel The withdraw request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    withdraw: async (
      withdrawModel: WithdrawModel,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'withdrawModel' is not null or undefined
      assertParamExists('withdraw', 'withdrawModel', withdrawModel);
      const localVarPath = `/api/v1/vaults/withdraw`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'x-api-key',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        withdrawModel,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WithdrawApi - functional programming interface
 * @export
 */
export const WithdrawApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WithdrawApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint allows for withdrawing assets from StarkExpress.
     * @summary Withdraw Asset
     * @param {WithdrawModel} withdrawModel The withdraw request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async withdraw(
      withdrawModel: WithdrawModel,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<WithdrawDetailsDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.withdraw(
        withdrawModel,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * WithdrawApi - factory interface
 * @export
 */
export const WithdrawApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = WithdrawApiFp(configuration);
  return {
    /**
     * This endpoint allows for withdrawing assets from StarkExpress.
     * @summary Withdraw Asset
     * @param {WithdrawModel} withdrawModel The withdraw request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    withdraw(
      withdrawModel: WithdrawModel,
      options?: any,
    ): AxiosPromise<WithdrawDetailsDto> {
      return localVarFp
        .withdraw(withdrawModel, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * WithdrawApi - object-oriented interface
 * @export
 * @class WithdrawApi
 * @extends {BaseAPI}
 */
export class WithdrawApi extends BaseAPI {
  /**
   * This endpoint allows for withdrawing assets from StarkExpress.
   * @summary Withdraw Asset
   * @param {WithdrawModel} withdrawModel The withdraw request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WithdrawApi
   */
  public withdraw(withdrawModel: WithdrawModel, options?: AxiosRequestConfig) {
    return WithdrawApiFp(this.configuration)
      .withdraw(withdrawModel, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
